{
  "version": 3,
  "sources": ["../../build/_snowpack/pkg/@vaadin/router.js", "../../build/_snowpack/pkg/uce.js", "../../build/javascript/greetings.js", "../../build/javascript/helpers/uuid.js", "../../build/javascript/palettes-list.js", "../../build/javascript/helpers/useState.js", "../../build/javascript/HandleStore.js", "../../build/javascript/palette-edit.js", "../../build/javascript/App.js"],
  "sourcesContent": ["function toArray(objectOrArray) {\n  objectOrArray = objectOrArray || [];\n  return Array.isArray(objectOrArray) ? objectOrArray : [objectOrArray];\n}\n\nfunction log(msg) {\n  return `[Vaadin.Router] ${msg}`;\n}\n\nfunction logValue(value) {\n  if (typeof value !== 'object') {\n    return String(value);\n  }\n\n  const stringType = Object.prototype.toString.call(value).match(/ (.*)\\]$/)[1];\n  if (stringType === 'Object' || stringType === 'Array') {\n    return `${stringType} ${JSON.stringify(value)}`;\n  } else {\n    return stringType;\n  }\n}\n\nconst MODULE = 'module';\nconst NOMODULE = 'nomodule';\nconst bundleKeys = [MODULE, NOMODULE];\n\nfunction ensureBundle(src) {\n  if (!src.match(/.+\\.[m]?js$/)) {\n    throw new Error(\n      log(`Unsupported type for bundle \"${src}\": .js or .mjs expected.`)\n    );\n  }\n}\n\nfunction ensureRoute(route) {\n  if (!route || !isString(route.path)) {\n    throw new Error(\n      log(`Expected route config to be an object with a \"path\" string property, or an array of such objects`)\n    );\n  }\n\n  const bundle = route.bundle;\n\n  const stringKeys = ['component', 'redirect', 'bundle'];\n  if (\n    !isFunction(route.action) &&\n    !Array.isArray(route.children) &&\n    !isFunction(route.children) &&\n    !isObject(bundle) &&\n    !stringKeys.some(key => isString(route[key]))\n  ) {\n    throw new Error(\n      log(\n        `Expected route config \"${route.path}\" to include either \"${stringKeys.join('\", \"')}\" ` +\n        `or \"action\" function but none found.`\n      )\n    );\n  }\n\n  if (bundle) {\n    if (isString(bundle)) {\n      ensureBundle(bundle);\n    } else if (!bundleKeys.some(key => key in bundle)) {\n      throw new Error(\n        log('Expected route bundle to include either \"' + NOMODULE + '\" or \"' + MODULE + '\" keys, or both')\n      );\n    } else {\n      bundleKeys.forEach(key => key in bundle && ensureBundle(bundle[key]));\n    }\n  }\n\n  if (route.redirect) {\n    ['bundle', 'component'].forEach(overriddenProp => {\n      if (overriddenProp in route) {\n        console.warn(\n          log(\n            `Route config \"${route.path}\" has both \"redirect\" and \"${overriddenProp}\" properties, ` +\n            `and \"redirect\" will always override the latter. Did you mean to only use \"${overriddenProp}\"?`\n          )\n        );\n      }\n    });\n  }\n}\n\nfunction ensureRoutes(routes) {\n  toArray(routes).forEach(route => ensureRoute(route));\n}\n\nfunction loadScript(src, key) {\n  let script = document.head.querySelector('script[src=\"' + src + '\"][async]');\n  if (!script) {\n    script = document.createElement('script');\n    script.setAttribute('src', src);\n    if (key === MODULE) {\n      script.setAttribute('type', MODULE);\n    } else if (key === NOMODULE) {\n      script.setAttribute(NOMODULE, '');\n    }\n    script.async = true;\n  }\n  return new Promise((resolve, reject) => {\n    script.onreadystatechange = script.onload = e => {\n      script.__dynamicImportLoaded = true;\n      resolve(e);\n    };\n    script.onerror = e => {\n      if (script.parentNode) {\n        script.parentNode.removeChild(script);\n      }\n      reject(e);\n    };\n    if (script.parentNode === null) {\n      document.head.appendChild(script);\n    } else if (script.__dynamicImportLoaded) {\n      resolve();\n    }\n  });\n}\n\nfunction loadBundle(bundle) {\n  if (isString(bundle)) {\n    return loadScript(bundle);\n  } else {\n    return Promise.race(\n      bundleKeys\n        .filter(key => key in bundle)\n        .map(key => loadScript(bundle[key], key))\n    );\n  }\n}\n\nfunction fireRouterEvent(type, detail) {\n  return !window.dispatchEvent(new CustomEvent(\n    `vaadin-router-${type}`,\n    {cancelable: type === 'go', detail}\n  ));\n}\n\nfunction isObject(o) {\n  // guard against null passing the typeof check\n  return typeof o === 'object' && !!o;\n}\n\nfunction isFunction(f) {\n  return typeof f === 'function';\n}\n\nfunction isString(s) {\n  return typeof s === 'string';\n}\n\nfunction getNotFoundError(context) {\n  const error = new Error(log(`Page not found (${context.pathname})`));\n  error.context = context;\n  error.code = 404;\n  return error;\n}\n\nconst notFoundResult = new (class NotFoundResult {})();\n\n/* istanbul ignore next: coverage is calculated in Chrome, this code is for IE */\nfunction getAnchorOrigin(anchor) {\n  // IE11: on HTTP and HTTPS the default port is not included into\n  // window.location.origin, so won't include it here either.\n  const port = anchor.port;\n  const protocol = anchor.protocol;\n  const defaultHttp = protocol === 'http:' && port === '80';\n  const defaultHttps = protocol === 'https:' && port === '443';\n  const host = (defaultHttp || defaultHttps)\n    ? anchor.hostname // does not include the port number (e.g. www.example.org)\n    : anchor.host; // does include the port number (e.g. www.example.org:80)\n  return `${protocol}//${host}`;\n}\n\n// The list of checks is not complete:\n//  - SVG support is missing\n//  - the 'rel' attribute is not considered\nfunction vaadinRouterGlobalClickHandler(event) {\n  // ignore the click if the default action is prevented\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  // ignore the click if not with the primary mouse button\n  if (event.button !== 0) {\n    return;\n  }\n\n  // ignore the click if a modifier key is pressed\n  if (event.shiftKey || event.ctrlKey || event.altKey || event.metaKey) {\n    return;\n  }\n\n  // find the <a> element that the click is at (or within)\n  let anchor = event.target;\n  const path = event.composedPath\n    ? event.composedPath()\n    : (event.path || []);\n\n  // FIXME(web-padawan): `Symbol.iterator` used by webcomponentsjs is broken for arrays\n  // example to check: `for...of` loop here throws the \"Not yet implemented\" error\n  for (let i = 0; i < path.length; i++) {\n    const target = path[i];\n    if (target.nodeName && target.nodeName.toLowerCase() === 'a') {\n      anchor = target;\n      break;\n    }\n  }\n\n  while (anchor && anchor.nodeName.toLowerCase() !== 'a') {\n    anchor = anchor.parentNode;\n  }\n\n  // ignore the click if not at an <a> element\n  if (!anchor || anchor.nodeName.toLowerCase() !== 'a') {\n    return;\n  }\n\n  // ignore the click if the <a> element has a non-default target\n  if (anchor.target && anchor.target.toLowerCase() !== '_self') {\n    return;\n  }\n\n  // ignore the click if the <a> element has the 'download' attribute\n  if (anchor.hasAttribute('download')) {\n    return;\n  }\n\n  // ignore the click if the <a> element has the 'router-ignore' attribute\n  if (anchor.hasAttribute('router-ignore')) {\n    return;\n  }\n\n  // ignore the click if the target URL is a fragment on the current page\n  if (anchor.pathname === window.location.pathname && anchor.hash !== '') {\n    return;\n  }\n\n  // ignore the click if the target is external to the app\n  // In IE11 HTMLAnchorElement does not have the `origin` property\n  const origin = anchor.origin || getAnchorOrigin(anchor);\n  if (origin !== window.location.origin) {\n    return;\n  }\n\n  // if none of the above, convert the click into a navigation event\n  const {pathname, search, hash} = anchor;\n  if (fireRouterEvent('go', {pathname, search, hash})) {\n    event.preventDefault();\n    // for a click event, the scroll is reset to the top position.\n    if (event && event.type === 'click') {\n      window.scrollTo(0, 0);\n    }\n  }\n}\n\n/**\n * A navigation trigger for Vaadin Router that translated clicks on `<a>` links\n * into Vaadin Router navigation events.\n *\n * Only regular clicks on in-app links are translated (primary mouse button, no\n * modifier keys, the target href is within the app's URL space).\n *\n * @memberOf Router.NavigationTrigger\n * @type {NavigationTrigger}\n */\nconst CLICK = {\n  activate() {\n    window.document.addEventListener('click', vaadinRouterGlobalClickHandler);\n  },\n\n  inactivate() {\n    window.document.removeEventListener('click', vaadinRouterGlobalClickHandler);\n  }\n};\n\n// PopStateEvent constructor shim\nconst isIE = /Trident/.test(navigator.userAgent);\n\n/* istanbul ignore next: coverage is calculated in Chrome, this code is for IE */\nif (isIE && !isFunction(window.PopStateEvent)) {\n  window.PopStateEvent = function(inType, params) {\n    params = params || {};\n    var e = document.createEvent('Event');\n    e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));\n    e.state = params.state || null;\n    return e;\n  };\n  window.PopStateEvent.prototype = window.Event.prototype;\n}\n\nfunction vaadinRouterGlobalPopstateHandler(event) {\n  if (event.state === 'vaadin-router-ignore') {\n    return;\n  }\n  const {pathname, search, hash} = window.location;\n  fireRouterEvent('go', {pathname, search, hash});\n}\n\n/**\n * A navigation trigger for Vaadin Router that translates popstate events into\n * Vaadin Router navigation events.\n *\n * @memberOf Router.NavigationTrigger\n * @type {NavigationTrigger}\n */\nconst POPSTATE = {\n  activate() {\n    window.addEventListener('popstate', vaadinRouterGlobalPopstateHandler);\n  },\n\n  inactivate() {\n    window.removeEventListener('popstate', vaadinRouterGlobalPopstateHandler);\n  }\n};\n\n/**\n * Expose `pathToRegexp`.\n */\nvar pathToRegexp_1 = pathToRegexp;\nvar parse_1 = parse;\nvar compile_1 = compile;\nvar tokensToFunction_1 = tokensToFunction;\nvar tokensToRegExp_1 = tokensToRegExp;\n\n/**\n * Default configs.\n */\nvar DEFAULT_DELIMITER = '/';\nvar DEFAULT_DELIMITERS = './';\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \":test(\\\\d+)?\" => [\"test\", \"\\d+\", undefined, \"?\"]\n  // \"(\\\\d+)\"  => [undefined, undefined, \"\\d+\", undefined]\n  '(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?'\n].join('|'), 'g');\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = [];\n  var key = 0;\n  var index = 0;\n  var path = '';\n  var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER;\n  var delimiters = (options && options.delimiters) || DEFAULT_DELIMITERS;\n  var pathEscaped = false;\n  var res;\n\n  while ((res = PATH_REGEXP.exec(str)) !== null) {\n    var m = res[0];\n    var escaped = res[1];\n    var offset = res.index;\n    path += str.slice(index, offset);\n    index = offset + m.length;\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1];\n      pathEscaped = true;\n      continue\n    }\n\n    var prev = '';\n    var next = str[index];\n    var name = res[2];\n    var capture = res[3];\n    var group = res[4];\n    var modifier = res[5];\n\n    if (!pathEscaped && path.length) {\n      var k = path.length - 1;\n\n      if (delimiters.indexOf(path[k]) > -1) {\n        prev = path[k];\n        path = path.slice(0, k);\n      }\n    }\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path);\n      path = '';\n      pathEscaped = false;\n    }\n\n    var partial = prev !== '' && next !== undefined && next !== prev;\n    var repeat = modifier === '+' || modifier === '*';\n    var optional = modifier === '?' || modifier === '*';\n    var delimiter = prev || defaultDelimiter;\n    var pattern = capture || group;\n\n    tokens.push({\n      name: name || key++,\n      prefix: prev,\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      pattern: pattern ? escapeGroup(pattern) : '[^' + escapeString(delimiter) + ']+?'\n    });\n  }\n\n  // Push any remaining characters.\n  if (path || index < str.length) {\n    tokens.push(path + str.substr(index));\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length);\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');\n    }\n  }\n\n  return function (data, options) {\n    var path = '';\n    var encode = (options && options.encode) || encodeURIComponent;\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n        continue\n      }\n\n      var value = data ? data[token.name] : undefined;\n      var segment;\n\n      if (Array.isArray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but got array')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) continue\n\n          throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j], token);\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\"')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n\n        continue\n      }\n\n      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        segment = encode(String(value), token);\n\n        if (!matches[i].test(segment)) {\n          throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but got \"' + segment + '\"')\n        }\n\n        path += token.prefix + segment;\n        continue\n      }\n\n      if (token.optional) {\n        // Prepend partial segment prefixes.\n        if (token.partial) path += token.prefix;\n\n        continue\n      }\n\n      throw new TypeError('Expected \"' + token.name + '\" to be ' + (token.repeat ? 'an array' : 'a string'))\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$/()])/g, '\\\\$1')\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options && options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {Array=}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  if (!keys) return path\n\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        pattern: null\n      });\n    }\n  }\n\n  return path\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = [];\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source);\n  }\n\n  return new RegExp('(?:' + parts.join('|') + ')', flags(options))\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}  tokens\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  options = options || {};\n\n  var strict = options.strict;\n  var start = options.start !== false;\n  var end = options.end !== false;\n  var delimiter = escapeString(options.delimiter || DEFAULT_DELIMITER);\n  var delimiters = options.delimiters || DEFAULT_DELIMITERS;\n  var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|');\n  var route = start ? '^' : '';\n  var isEndDelimited = tokens.length === 0;\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (typeof token === 'string') {\n      route += escapeString(token);\n      isEndDelimited = i === tokens.length - 1 && delimiters.indexOf(token[token.length - 1]) > -1;\n    } else {\n      var capture = token.repeat\n        ? '(?:' + token.pattern + ')(?:' + escapeString(token.delimiter) + '(?:' + token.pattern + '))*'\n        : token.pattern;\n\n      if (keys) keys.push(token);\n\n      if (token.optional) {\n        if (token.partial) {\n          route += escapeString(token.prefix) + '(' + capture + ')?';\n        } else {\n          route += '(?:' + escapeString(token.prefix) + '(' + capture + '))?';\n        }\n      } else {\n        route += escapeString(token.prefix) + '(' + capture + ')';\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += '(?:' + delimiter + ')?';\n\n    route += endsWith === '$' ? '$' : '(?=' + endsWith + ')';\n  } else {\n    if (!strict) route += '(?:' + delimiter + '(?=' + endsWith + '))?';\n    if (!isEndDelimited) route += '(?=' + delimiter + '|' + endsWith + ')';\n  }\n\n  return new RegExp(route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {Array=}                keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys)\n  }\n\n  if (Array.isArray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), keys, options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), keys, options)\n}\npathToRegexp_1.parse = parse_1;\npathToRegexp_1.compile = compile_1;\npathToRegexp_1.tokensToFunction = tokensToFunction_1;\npathToRegexp_1.tokensToRegExp = tokensToRegExp_1;\n\n/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nconst {hasOwnProperty} = Object.prototype;\nconst cache = new Map();\n// see https://github.com/pillarjs/path-to-regexp/issues/148\ncache.set('|false', {\n  keys: [],\n  pattern: /(?:)/\n});\n\nfunction decodeParam(val) {\n  try {\n    return decodeURIComponent(val);\n  } catch (err) {\n    return val;\n  }\n}\n\nfunction matchPath(routepath, path, exact, parentKeys, parentParams) {\n  exact = !!exact;\n  const cacheKey = `${routepath}|${exact}`;\n  let regexp = cache.get(cacheKey);\n\n  if (!regexp) {\n    const keys = [];\n    regexp = {\n      keys,\n      pattern: pathToRegexp_1(routepath, keys, {\n        end: exact,\n        strict: routepath === ''\n      }),\n    };\n    cache.set(cacheKey, regexp);\n  }\n\n  const m = regexp.pattern.exec(path);\n  if (!m) {\n    return null;\n  }\n\n  const params = Object.assign({}, parentParams);\n\n  for (let i = 1; i < m.length; i++) {\n    const key = regexp.keys[i - 1];\n    const prop = key.name;\n    const value = m[i];\n    if (value !== undefined || !hasOwnProperty.call(params, prop)) {\n      if (key.repeat) {\n        params[prop] = value ? value.split(key.delimiter).map(decodeParam) : [];\n      } else {\n        params[prop] = value ? decodeParam(value) : value;\n      }\n    }\n  }\n\n  return {\n    path: m[0],\n    keys: (parentKeys || []).concat(regexp.keys),\n    params,\n  };\n}\n\n/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\n/**\n * Traverses the routes tree and matches its nodes to the given pathname from\n * the root down to the leaves. Each match consumes a part of the pathname and\n * the matching process continues for as long as there is a matching child\n * route for the remaining part of the pathname.\n *\n * The returned value is a lazily evaluated iterator.\n *\n * The leading \"/\" in a route path matters only for the root of the routes\n * tree (or if all parent routes are \"\"). In all other cases a leading \"/\" in\n * a child route path has no significance.\n *\n * The trailing \"/\" in a _route path_ matters only for the leaves of the\n * routes tree. A leaf route with a trailing \"/\" matches only a pathname that\n * also has a trailing \"/\".\n *\n * The trailing \"/\" in a route path does not affect matching of child routes\n * in any way.\n *\n * The trailing \"/\" in a _pathname_ generally does not matter (except for\n * the case of leaf nodes described above).\n *\n * The \"\" and \"/\" routes have special treatment:\n *  1. as a single route\n *     the \"\" and \"/\" routes match only the \"\" and \"/\" pathnames respectively\n *  2. as a parent in the routes tree\n *     the \"\" route matches any pathname without consuming any part of it\n *     the \"/\" route matches any absolute pathname consuming its leading \"/\"\n *  3. as a leaf in the routes tree\n *     the \"\" and \"/\" routes match only if the entire pathname is consumed by\n *         the parent routes chain. In this case \"\" and \"/\" are equivalent.\n *  4. several directly nested \"\" or \"/\" routes\n *     - directly nested \"\" or \"/\" routes are 'squashed' (i.e. nesting two\n *       \"/\" routes does not require a double \"/\" in the pathname to match)\n *     - if there are only \"\" in the parent routes chain, no part of the\n *       pathname is consumed, and the leading \"/\" in the child routes' paths\n *       remains significant\n *\n * Side effect:\n *   - the routes tree { path: '' } matches only the '' pathname\n *   - the routes tree { path: '', children: [ { path: '' } ] } matches any\n *     pathname (for the tree root)\n *\n * Prefix matching can be enabled also by `children: true`.\n */\nfunction matchRoute(route, pathname, ignoreLeadingSlash, parentKeys, parentParams) {\n  let match;\n  let childMatches;\n  let childIndex = 0;\n  let routepath = route.path || '';\n  if (routepath.charAt(0) === '/') {\n    if (ignoreLeadingSlash) {\n      routepath = routepath.substr(1);\n    }\n    ignoreLeadingSlash = true;\n  }\n\n  return {\n    next(routeToSkip) {\n      if (route === routeToSkip) {\n        return {done: true};\n      }\n\n      const children = route.__children = route.__children || route.children;\n\n      if (!match) {\n        match = matchPath(routepath, pathname, !children, parentKeys, parentParams);\n\n        if (match) {\n          return {\n            done: false,\n            value: {\n              route,\n              keys: match.keys,\n              params: match.params,\n              path: match.path\n            },\n          };\n        }\n      }\n\n      if (match && children) {\n        while (childIndex < children.length) {\n          if (!childMatches) {\n            const childRoute = children[childIndex];\n            childRoute.parent = route;\n\n            let matchedLength = match.path.length;\n            if (matchedLength > 0 && pathname.charAt(matchedLength) === '/') {\n              matchedLength += 1;\n            }\n\n            childMatches = matchRoute(\n              childRoute,\n              pathname.substr(matchedLength),\n              ignoreLeadingSlash,\n              match.keys,\n              match.params\n            );\n          }\n\n          const childMatch = childMatches.next(routeToSkip);\n          if (!childMatch.done) {\n            return {\n              done: false,\n              value: childMatch.value,\n            };\n          }\n\n          childMatches = null;\n          childIndex++;\n        }\n      }\n\n      return {done: true};\n    },\n  };\n}\n\n/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nfunction resolveRoute(context) {\n  if (isFunction(context.route.action)) {\n    return context.route.action(context);\n  }\n  return undefined;\n}\n\n/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nfunction isChildRoute(parentRoute, childRoute) {\n  let route = childRoute;\n  while (route) {\n    route = route.parent;\n    if (route === parentRoute) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction generateErrorMessage(currentContext) {\n  let errorMessage = `Path '${currentContext.pathname}' is not properly resolved due to an error.`;\n  const routePath = (currentContext.route || {}).path;\n  if (routePath) {\n    errorMessage += ` Resolution had failed on route: '${routePath}'`;\n  }\n  return errorMessage;\n}\n\nfunction updateChainForRoute(context, match) {\n  const {route, path} = match;\n\n  if (route && !route.__synthetic) {\n    const item = {path, route};\n    if (!context.chain) {\n      context.chain = [];\n    } else {\n      // Discard old items\n      if (route.parent) {\n        let i = context.chain.length;\n        while (i-- && context.chain[i].route && context.chain[i].route !== route.parent) {\n          context.chain.pop();\n        }\n      }\n    }\n    context.chain.push(item);\n  }\n}\n\n/**\n */\nclass Resolver {\n  constructor(routes, options = {}) {\n    if (Object(routes) !== routes) {\n      throw new TypeError('Invalid routes');\n    }\n\n    this.baseUrl = options.baseUrl || '';\n    this.errorHandler = options.errorHandler;\n    this.resolveRoute = options.resolveRoute || resolveRoute;\n    this.context = Object.assign({resolver: this}, options.context);\n    this.root = Array.isArray(routes) ? {path: '', __children: routes, parent: null, __synthetic: true} : routes;\n    this.root.parent = null;\n  }\n\n  /**\n   * Returns the current list of routes (as a shallow copy). Adding / removing\n   * routes to / from the returned array does not affect the routing config,\n   * but modifying the route objects does.\n   *\n   * @return {!Array<!Router.Route>}\n   */\n  getRoutes() {\n    return [...this.root.__children];\n  }\n\n  /**\n   * Sets the routing config (replacing the existing one).\n   *\n   * @param {!Array<!Router.Route>|!Router.Route} routes a single route or an array of those\n   *    (the array is shallow copied)\n   */\n  setRoutes(routes) {\n    ensureRoutes(routes);\n    const newRoutes = [...toArray(routes)];\n    this.root.__children = newRoutes;\n  }\n\n  /**\n   * Appends one or several routes to the routing config and returns the\n   * effective routing config after the operation.\n   *\n   * @param {!Array<!Router.Route>|!Router.Route} routes a single route or an array of those\n   *    (the array is shallow copied)\n   * @return {!Array<!Router.Route>}\n   * @protected\n   */\n  addRoutes(routes) {\n    ensureRoutes(routes);\n    this.root.__children.push(...toArray(routes));\n    return this.getRoutes();\n  }\n\n  /**\n   * Removes all existing routes from the routing config.\n   */\n  removeRoutes() {\n    this.setRoutes([]);\n  }\n\n  /**\n   * Asynchronously resolves the given pathname, i.e. finds all routes matching\n   * the pathname and tries resolving them one after another in the order they\n   * are listed in the routes config until the first non-null result.\n   *\n   * Returns a promise that is fulfilled with the return value of an object that consists of the first\n   * route handler result that returns something other than `null` or `undefined` and context used to get this result.\n   *\n   * If no route handlers return a non-null result, or if no route matches the\n   * given pathname the returned promise is rejected with a 'page not found'\n   * `Error`.\n   *\n   * @param {!string|!{pathname: !string}} pathnameOrContext the pathname to\n   *    resolve or a context object with a `pathname` property and other\n   *    properties to pass to the route resolver functions.\n   * @return {!Promise<any>}\n   */\n  resolve(pathnameOrContext) {\n    const context = Object.assign(\n      {},\n      this.context,\n      isString(pathnameOrContext) ? {pathname: pathnameOrContext} : pathnameOrContext\n    );\n    const match = matchRoute(\n      this.root,\n      this.__normalizePathname(context.pathname),\n      this.baseUrl\n    );\n    const resolve = this.resolveRoute;\n    let matches = null;\n    let nextMatches = null;\n    let currentContext = context;\n\n    function next(resume, parent = matches.value.route, prevResult) {\n      const routeToSkip = prevResult === null && matches.value.route;\n      matches = nextMatches || match.next(routeToSkip);\n      nextMatches = null;\n\n      if (!resume) {\n        if (matches.done || !isChildRoute(parent, matches.value.route)) {\n          nextMatches = matches;\n          return Promise.resolve(notFoundResult);\n        }\n      }\n\n      if (matches.done) {\n        return Promise.reject(getNotFoundError(context));\n      }\n\n      currentContext = Object.assign(\n        currentContext\n          ? {chain: (currentContext.chain ? currentContext.chain.slice(0) : [])}\n          : {},\n        context,\n        matches.value\n      );\n      updateChainForRoute(currentContext, matches.value);\n\n      return Promise.resolve(resolve(currentContext)).then(resolution => {\n        if (resolution !== null && resolution !== undefined && resolution !== notFoundResult) {\n          currentContext.result = resolution.result || resolution;\n          return currentContext;\n        }\n        return next(resume, parent, resolution);\n      });\n    }\n\n    context.next = next;\n\n    return Promise.resolve()\n      .then(() => next(true, this.root))\n      .catch((error) => {\n        const errorMessage = generateErrorMessage(currentContext);\n        if (!error) {\n          error = new Error(errorMessage);\n        } else {\n          console.warn(errorMessage);\n        }\n        error.context = error.context || currentContext;\n        // DOMException has its own code which is read-only\n        if (!(error instanceof DOMException)) {\n          error.code = error.code || 500;\n        }\n        if (this.errorHandler) {\n          currentContext.result = this.errorHandler(error);\n          return currentContext;\n        }\n        throw error;\n      });\n  }\n\n  /**\n   * URL constructor polyfill hook. Creates and returns an URL instance.\n   */\n  static __createUrl(url, base) {\n    return new URL(url, base);\n  }\n\n  /**\n   * If the baseUrl property is set, transforms the baseUrl and returns the full\n   * actual `base` string for using in the `new URL(path, base);` and for\n   * prepernding the paths with. The returned base ends with a trailing slash.\n   *\n   * Otherwise, returns empty string.\n   */\n  get __effectiveBaseUrl() {\n    return this.baseUrl\n      ? this.constructor.__createUrl(\n        this.baseUrl,\n        document.baseURI || document.URL\n      ).href.replace(/[^\\/]*$/, '')\n      : '';\n  }\n\n  /**\n   * If the baseUrl is set, matches the pathname with the router’s baseUrl,\n   * and returns the local pathname with the baseUrl stripped out.\n   *\n   * If the pathname does not match the baseUrl, returns undefined.\n   *\n   * If the `baseUrl` is not set, returns the unmodified pathname argument.\n   */\n  __normalizePathname(pathname) {\n    if (!this.baseUrl) {\n      // No base URL, no need to transform the pathname.\n      return pathname;\n    }\n\n    const base = this.__effectiveBaseUrl;\n    const normalizedUrl = this.constructor.__createUrl(pathname, base).href;\n    if (normalizedUrl.slice(0, base.length) === base) {\n      return normalizedUrl.slice(base.length);\n    }\n  }\n}\n\nResolver.pathToRegexp = pathToRegexp_1;\n\n/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nconst {pathToRegexp: pathToRegexp$1} = Resolver;\nconst cache$1 = new Map();\n\nfunction cacheRoutes(routesByName, route, routes) {\n  const name = route.name || route.component;\n  if (name) {\n    if (routesByName.has(name)) {\n      routesByName.get(name).push(route);\n    } else {\n      routesByName.set(name, [route]);\n    }\n  }\n\n  if (Array.isArray(routes)) {\n    for (let i = 0; i < routes.length; i++) {\n      const childRoute = routes[i];\n      childRoute.parent = route;\n      cacheRoutes(routesByName, childRoute, childRoute.__children || childRoute.children);\n    }\n  }\n}\n\nfunction getRouteByName(routesByName, routeName) {\n  const routes = routesByName.get(routeName);\n  if (routes && routes.length > 1) {\n    throw new Error(\n      `Duplicate route with name \"${routeName}\".`\n      + ` Try seting unique 'name' route properties.`\n    );\n  }\n  return routes && routes[0];\n}\n\nfunction getRoutePath(route) {\n  let path = route.path;\n  path = Array.isArray(path) ? path[0] : path;\n  return path !== undefined ? path : '';\n}\n\nfunction generateUrls(router, options = {}) {\n  if (!(router instanceof Resolver)) {\n    throw new TypeError('An instance of Resolver is expected');\n  }\n\n  const routesByName = new Map();\n\n  return (routeName, params) => {\n    let route = getRouteByName(routesByName, routeName);\n    if (!route) {\n      routesByName.clear(); // clear cache\n      cacheRoutes(routesByName, router.root, router.root.__children);\n\n      route = getRouteByName(routesByName, routeName);\n      if (!route) {\n        throw new Error(`Route \"${routeName}\" not found`);\n      }\n    }\n\n    let regexp = cache$1.get(route.fullPath);\n    if (!regexp) {\n      let fullPath = getRoutePath(route);\n      let rt = route.parent;\n      while (rt) {\n        const path = getRoutePath(rt);\n        if (path) {\n          fullPath = path.replace(/\\/$/, '') + '/' + fullPath.replace(/^\\//, '');\n        }\n        rt = rt.parent;\n      }\n      const tokens = pathToRegexp$1.parse(fullPath);\n      const toPath = pathToRegexp$1.tokensToFunction(tokens);\n      const keys = Object.create(null);\n      for (let i = 0; i < tokens.length; i++) {\n        if (!isString(tokens[i])) {\n          keys[tokens[i].name] = true;\n        }\n      }\n      regexp = {toPath, keys};\n      cache$1.set(fullPath, regexp);\n      route.fullPath = fullPath;\n    }\n\n    let url = regexp.toPath(params, options) || '/';\n\n    if (options.stringifyQueryParams && params) {\n      const queryParams = {};\n      const keys = Object.keys(params);\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if (!regexp.keys[key]) {\n          queryParams[key] = params[key];\n        }\n      }\n      const query = options.stringifyQueryParams(queryParams);\n      if (query) {\n        url += query.charAt(0) === '?' ? query : `?${query}`;\n      }\n    }\n\n    return url;\n  };\n}\n\n/**\n * @typedef NavigationTrigger\n * @type {object}\n * @property {function()} activate\n * @property {function()} inactivate\n */\n\n/** @type {Array<NavigationTrigger>} */\nlet triggers = [];\n\nfunction setNavigationTriggers(newTriggers) {\n  triggers.forEach(trigger => trigger.inactivate());\n\n  newTriggers.forEach(trigger => trigger.activate());\n\n  triggers = newTriggers;\n}\n\nconst willAnimate = elem => {\n  const name = getComputedStyle(elem).getPropertyValue('animation-name');\n  return name && name !== 'none';\n};\n\nconst waitForAnimation = (elem, cb) => {\n  const listener = () => {\n    elem.removeEventListener('animationend', listener);\n    cb();\n  };\n  elem.addEventListener('animationend', listener);\n};\n\nfunction animate(elem, className) {\n  elem.classList.add(className);\n\n  return new Promise(resolve => {\n    if (willAnimate(elem)) {\n      const rect = elem.getBoundingClientRect();\n      const size = `height: ${rect.bottom - rect.top}px; width: ${rect.right - rect.left}px`;\n      elem.setAttribute('style', `position: absolute; ${size}`);\n      waitForAnimation(elem, () => {\n        elem.classList.remove(className);\n        elem.removeAttribute('style');\n        resolve();\n      });\n    } else {\n      elem.classList.remove(className);\n      resolve();\n    }\n  });\n}\n\nconst MAX_REDIRECT_COUNT = 256;\n\nfunction isResultNotEmpty(result) {\n  return result !== null && result !== undefined;\n}\n\nfunction copyContextWithoutNext(context) {\n  const copy = Object.assign({}, context);\n  delete copy.next;\n  return copy;\n}\n\nfunction createLocation({pathname = '', search = '', hash = '', chain = [], params = {}, redirectFrom, resolver}, route) {\n  const routes = chain.map(item => item.route);\n  return {\n    baseUrl: resolver && resolver.baseUrl || '',\n    pathname,\n    search,\n    hash,\n    routes,\n    route: route || routes.length && routes[routes.length - 1] || null,\n    params,\n    redirectFrom,\n    getUrl: (userParams = {}) => getPathnameForRouter(\n      Router.pathToRegexp.compile(\n        getMatchedPath(routes)\n      )(Object.assign({}, params, userParams)),\n      resolver\n    )\n  };\n}\n\nfunction createRedirect(context, pathname) {\n  const params = Object.assign({}, context.params);\n  return {\n    redirect: {\n      pathname,\n      from: context.pathname,\n      params\n    }\n  };\n}\n\nfunction renderElement(context, element) {\n  element.location = createLocation(context);\n  const index = context.chain.map(item => item.route).indexOf(context.route);\n  context.chain[index].element = element;\n  return element;\n}\n\nfunction runCallbackIfPossible(callback, args, thisArg) {\n  if (isFunction(callback)) {\n    return callback.apply(thisArg, args);\n  }\n}\n\nfunction amend(amendmentFunction, args, element) {\n  return amendmentResult => {\n    if (amendmentResult && (amendmentResult.cancel || amendmentResult.redirect)) {\n      return amendmentResult;\n    }\n\n    if (element) {\n      return runCallbackIfPossible(element[amendmentFunction], args, element);\n    }\n  };\n}\n\nfunction processNewChildren(newChildren, route) {\n  if (!Array.isArray(newChildren) && !isObject(newChildren)) {\n    throw new Error(\n      log(\n        `Incorrect \"children\" value for the route ${route.path}: expected array or object, but got ${newChildren}`\n      )\n    );\n  }\n\n  route.__children = [];\n  const childRoutes = toArray(newChildren);\n  for (let i = 0; i < childRoutes.length; i++) {\n    ensureRoute(childRoutes[i]);\n    route.__children.push(childRoutes[i]);\n  }\n}\n\nfunction removeDomNodes(nodes) {\n  if (nodes && nodes.length) {\n    const parent = nodes[0].parentNode;\n    for (let i = 0; i < nodes.length; i++) {\n      parent.removeChild(nodes[i]);\n    }\n  }\n}\n\nfunction getPathnameForRouter(pathname, router) {\n  const base = router.__effectiveBaseUrl;\n  return base\n    ? router.constructor.__createUrl(pathname.replace(/^\\//, ''), base).pathname\n    : pathname;\n}\n\nfunction getMatchedPath(chain) {\n  return chain.map(item => item.path).reduce((a, b) => {\n    if (b.length) {\n      return a.replace(/\\/$/, '') + '/' + b.replace(/^\\//, '');\n    }\n    return a;\n  }, '');\n}\n\n/**\n * A simple client-side router for single-page applications. It uses\n * express-style middleware and has a first-class support for Web Components and\n * lazy-loading. Works great in Polymer and non-Polymer apps.\n *\n * Use `new Router(outlet, options)` to create a new Router instance.\n *\n * * The `outlet` parameter is a reference to the DOM node to render\n *   the content into.\n *\n * * The `options` parameter is an optional object with options. The following\n *   keys are supported:\n *   * `baseUrl` — the initial value for [\n *     the `baseUrl` property\n *   ](#/classes/Router#property-baseUrl)\n *\n * The Router instance is automatically subscribed to navigation events\n * on `window`.\n *\n * See [Live Examples](#/classes/Router/demos/demo/index.html) for the detailed usage demo and code snippets.\n *\n * See also detailed API docs for the following methods, for the advanced usage:\n *\n * * [setOutlet](#/classes/Router#method-setOutlet) – should be used to configure the outlet.\n * * [setTriggers](#/classes/Router#method-setTriggers) – should be used to configure the navigation events.\n * * [setRoutes](#/classes/Router#method-setRoutes) – should be used to configure the routes.\n *\n * Only `setRoutes` has to be called manually, others are automatically invoked when creating a new instance.\n *\n * @extends Resolver\n * @demo demo/index.html\n * @summary JavaScript class that renders different DOM content depending on\n *    a given path. It can re-render when triggered or automatically on\n *    'popstate' and / or 'click' events.\n */\nclass Router extends Resolver {\n\n  /**\n   * Creates a new Router instance with a given outlet, and\n   * automatically subscribes it to navigation events on the `window`.\n   * Using a constructor argument or a setter for outlet is equivalent:\n   *\n   * ```\n   * const router = new Router();\n   * router.setOutlet(outlet);\n   * ```\n   * @param {?Node=} outlet\n   * @param {?RouterOptions=} options\n   */\n  constructor(outlet, options) {\n    const baseElement = document.head.querySelector('base');\n    const baseHref = baseElement && baseElement.getAttribute('href');\n    super([], Object.assign({\n      // Default options\n      baseUrl: baseHref && Resolver.__createUrl(baseHref, document.URL).pathname.replace(/[^\\/]*$/, '')\n    }, options));\n\n    this.resolveRoute = context => this.__resolveRoute(context);\n\n    const triggers = Router.NavigationTrigger;\n    Router.setTriggers.apply(Router, Object.keys(triggers).map(key => triggers[key]));\n\n    /**\n     * The base URL for all routes in the router instance. By default,\n     * if the base element exists in the `<head>`, vaadin-router\n     * takes the `<base href>` attribute value, resolves against current `document.URL`\n     * and gets the `pathname` from the result.\n     *\n     * @public\n     * @type {string}\n     */\n    this.baseUrl;\n\n    /**\n     * A promise that is settled after the current render cycle completes. If\n     * there is no render cycle in progress the promise is immediately settled\n     * with the last render cycle result.\n     *\n     * @public\n     * @type {!Promise<!RouterLocation>}\n     */\n    this.ready;\n    this.ready = Promise.resolve(outlet);\n\n    /**\n     * Contains read-only information about the current router location:\n     * pathname, active routes, parameters. See the\n     * [Location type declaration](#/classes/RouterLocation)\n     * for more details.\n     *\n     * @public\n     * @type {!RouterLocation}\n     */\n    this.location;\n    this.location = createLocation({resolver: this});\n\n    this.__lastStartedRenderId = 0;\n    this.__navigationEventHandler = this.__onNavigationEvent.bind(this);\n    this.setOutlet(outlet);\n    this.subscribe();\n    // Using WeakMap instead of WeakSet because WeakSet is not supported by IE11\n    this.__createdByRouter = new WeakMap();\n    this.__addedByRouter = new WeakMap();\n  }\n\n  __resolveRoute(context) {\n    const route = context.route;\n\n    let callbacks = Promise.resolve();\n\n    if (isFunction(route.children)) {\n      callbacks = callbacks\n        .then(() => route.children(copyContextWithoutNext(context)))\n        .then(children => {\n          // The route.children() callback might have re-written the\n          // route.children property instead of returning a value\n          if (!isResultNotEmpty(children) && !isFunction(route.children)) {\n            children = route.children;\n          }\n          processNewChildren(children, route);\n        });\n    }\n\n    const commands = {\n      redirect: path => createRedirect(context, path),\n      component: (component) => {\n        const element = document.createElement(component);\n        this.__createdByRouter.set(element, true);\n        return element;\n      }\n    };\n\n    return callbacks\n      .then(() => {\n        if (this.__isLatestRender(context)) {\n          return runCallbackIfPossible(route.action, [context, commands], route);\n        }\n      })\n      .then(result => {\n        if (isResultNotEmpty(result)) {\n          // Actions like `() => import('my-view.js')` are not expected to\n          // end the resolution, despite the result is not empty. Checking\n          // the result with a whitelist of values that end the resolution.\n          if (result instanceof HTMLElement ||\n              result.redirect ||\n              result === notFoundResult) {\n            return result;\n          }\n        }\n\n        if (isString(route.redirect)) {\n          return commands.redirect(route.redirect);\n        }\n\n        if (route.bundle) {\n          return loadBundle(route.bundle)\n            .then(() => {}, () => {\n              throw new Error(log(`Bundle not found: ${route.bundle}. Check if the file name is correct`));\n            });\n        }\n      })\n      .then(result => {\n        if (isResultNotEmpty(result)) {\n          return result;\n        }\n        if (isString(route.component)) {\n          return commands.component(route.component);\n        }\n      });\n  }\n\n  /**\n   * Sets the router outlet (the DOM node where the content for the current\n   * route is inserted). Any content pre-existing in the router outlet is\n   * removed at the end of each render pass.\n   *\n   * NOTE: this method is automatically invoked first time when creating a new Router instance.\n   *\n   * @param {?Node} outlet the DOM node where the content for the current route\n   *     is inserted.\n   */\n  setOutlet(outlet) {\n    if (outlet) {\n      this.__ensureOutlet(outlet);\n    }\n    this.__outlet = outlet;\n  }\n\n  /**\n   * Returns the current router outlet. The initial value is `undefined`.\n   *\n   * @return {?Node} the current router outlet (or `undefined`)\n   */\n  getOutlet() {\n    return this.__outlet;\n  }\n\n  /**\n   * Sets the routing config (replacing the existing one) and triggers a\n   * navigation event so that the router outlet is refreshed according to the\n   * current `window.location` and the new routing config.\n   *\n   * Each route object may have the following properties, listed here in the processing order:\n   * * `path` – the route path (relative to the parent route if any) in the\n   * [express.js syntax](https://expressjs.com/en/guide/routing.html#route-paths\").\n   *\n   * * `children` – an array of nested routes or a function that provides this\n   * array at the render time. The function can be synchronous or asynchronous:\n   * in the latter case the render is delayed until the returned promise is\n   * resolved. The `children` function is executed every time when this route is\n   * being rendered. This allows for dynamic route structures (e.g. backend-defined),\n   * but it might have a performance impact as well. In order to avoid calling\n   * the function on subsequent renders, you can override the `children` property\n   * of the route object and save the calculated array there\n   * (via `context.route.children = [ route1, route2, ...];`).\n   * Parent routes are fully resolved before resolving the children. Children\n   * 'path' values are relative to the parent ones.\n   *\n   * * `action` – the action that is executed before the route is resolved.\n   * The value for this property should be a function, accepting `context`\n   * and `commands` parameters described below. If present, this function is\n   * always invoked first, disregarding of the other properties' presence.\n   * The action can return a result directly or within a `Promise`, which\n   * resolves to the result. If the action result is an `HTMLElement` instance,\n   * a `commands.component(name)` result, a `commands.redirect(path)` result,\n   * or a `context.next()` result, the current route resolution is finished,\n   * and other route config properties are ignored.\n   * See also **Route Actions** section in [Live Examples](#/classes/Router/demos/demo/index.html).\n   *\n   * * `redirect` – other route's path to redirect to. Passes all route parameters to the redirect target.\n   * The target route should also be defined.\n   * See also **Redirects** section in [Live Examples](#/classes/Router/demos/demo/index.html).\n   *\n   * * `bundle` – string containing the path to `.js` or `.mjs` bundle to load before resolving the route,\n   * or the object with \"module\" and \"nomodule\" keys referring to different bundles.\n   * Each bundle is only loaded once. If \"module\" and \"nomodule\" are set, only one bundle is loaded,\n   * depending on whether the browser supports ES modules or not.\n   * The property is ignored when either an `action` returns the result or `redirect` property is present.\n   * Any error, e.g. 404 while loading bundle will cause route resolution to throw.\n   * See also **Code Splitting** section in [Live Examples](#/classes/Router/demos/demo/index.html).\n   *\n   * * `component` – the tag name of the Web Component to resolve the route to.\n   * The property is ignored when either an `action` returns the result or `redirect` property is present.\n   * If route contains the `component` property (or an action that return a component)\n   * and its child route also contains the `component` property, child route's component\n   * will be rendered as a light dom child of a parent component.\n   *\n   * * `name` – the string name of the route to use in the\n   * [`router.urlForName(name, params)`](#/classes/Router#method-urlForName)\n   * navigation helper method.\n   *\n   * For any route function (`action`, `children`) defined, the corresponding `route` object is available inside the callback\n   * through the `this` reference. If you need to access it, make sure you define the callback as a non-arrow function\n   * because arrow functions do not have their own `this` reference.\n   *\n   * `context` object that is passed to `action` function holds the following properties:\n   * * `context.pathname` – string with the pathname being resolved\n   *\n   * * `context.search` – search query string\n   *\n   * * `context.hash` – hash string\n   *\n   * * `context.params` – object with route parameters\n   *\n   * * `context.route` – object that holds the route that is currently being rendered.\n   *\n   * * `context.next()` – function for asynchronously getting the next route\n   * contents from the resolution chain (if any)\n   *\n   * `commands` object that is passed to `action` function has\n   * the following methods:\n   *\n   * * `commands.redirect(path)` – function that creates a redirect data\n   * for the path specified.\n   *\n   * * `commands.component(component)` – function that creates a new HTMLElement\n   * with current context. Note: the component created by this function is reused if visiting the same path twice in row.\n   *\n   *\n   * @param {!Array<!Route>|!Route} routes a single route or an array of those\n   * @param {?boolean} skipRender configure the router but skip rendering the\n   *     route corresponding to the current `window.location` values\n   *\n   * @return {!Promise<!Node>}\n   */\n  setRoutes(routes, skipRender = false) {\n    this.__previousContext = undefined;\n    this.__urlForName = undefined;\n    super.setRoutes(routes);\n    if (!skipRender) {\n      this.__onNavigationEvent();\n    }\n    return this.ready;\n  }\n\n  /**\n   * Asynchronously resolves the given pathname and renders the resolved route\n   * component into the router outlet. If no router outlet is set at the time of\n   * calling this method, or at the time when the route resolution is completed,\n   * a `TypeError` is thrown.\n   *\n   * Returns a promise that is fulfilled with the router outlet DOM Node after\n   * the route component is created and inserted into the router outlet, or\n   * rejected if no route matches the given path.\n   *\n   * If another render pass is started before the previous one is completed, the\n   * result of the previous render pass is ignored.\n   *\n   * @param {!string|!{pathname: !string, search: ?string, hash: ?string}} pathnameOrContext\n   *    the pathname to render or a context object with a `pathname` property,\n   *    optional `search` and `hash` properties, and other properties\n   *    to pass to the resolver.\n   * @param {boolean=} shouldUpdateHistory\n   *    update browser history with the rendered location\n   * @return {!Promise<!Node>}\n   */\n  render(pathnameOrContext, shouldUpdateHistory) {\n    const renderId = ++this.__lastStartedRenderId;\n    const context = Object.assign(\n      {\n        search: '',\n        hash: ''\n      },\n      isString(pathnameOrContext)\n        ? {pathname: pathnameOrContext}\n        : pathnameOrContext,\n      {\n        __renderId: renderId\n      }\n    );\n\n    // Find the first route that resolves to a non-empty result\n    this.ready = this.resolve(context)\n\n      // Process the result of this.resolve() and handle all special commands:\n      // (redirect / prevent / component). If the result is a 'component',\n      // then go deeper and build the entire chain of nested components matching\n      // the pathname. Also call all 'on before' callbacks along the way.\n      .then(context => this.__fullyResolveChain(context))\n\n      .then(context => {\n        if (this.__isLatestRender(context)) {\n          const previousContext = this.__previousContext;\n\n          // Check if the render was prevented and make an early return in that case\n          if (context === previousContext) {\n            // Replace the history with the previous context\n            // to make sure the URL stays the same.\n            this.__updateBrowserHistory(previousContext, true);\n            return this.location;\n          }\n\n          this.location = createLocation(context);\n\n          if (shouldUpdateHistory) {\n            // Replace only if first render redirects, so that we don’t leave\n            // the redirecting record in the history\n            this.__updateBrowserHistory(context, renderId === 1);\n          }\n\n          fireRouterEvent('location-changed', {router: this, location: this.location});\n\n          // Skip detaching/re-attaching there are no render changes\n          if (context.__skipAttach) {\n            this.__copyUnchangedElements(context, previousContext);\n            this.__previousContext = context;\n            return this.location;\n          }\n\n          this.__addAppearingContent(context, previousContext);\n          const animationDone = this.__animateIfNeeded(context);\n\n          this.__runOnAfterEnterCallbacks(context);\n          this.__runOnAfterLeaveCallbacks(context, previousContext);\n\n          return animationDone.then(() => {\n            if (this.__isLatestRender(context)) {\n              // If there is another render pass started after this one,\n              // the 'disappearing content' would be removed when the other\n              // render pass calls `this.__addAppearingContent()`\n              this.__removeDisappearingContent();\n\n              this.__previousContext = context;\n              return this.location;\n            }\n          });\n        }\n      })\n      .catch(error => {\n        if (renderId === this.__lastStartedRenderId) {\n          if (shouldUpdateHistory) {\n            this.__updateBrowserHistory(context);\n          }\n          removeDomNodes(this.__outlet && this.__outlet.children);\n          this.location = createLocation(Object.assign(context, {resolver: this}));\n          fireRouterEvent('error', Object.assign({router: this, error}, context));\n          throw error;\n        }\n      });\n    return this.ready;\n  }\n\n  // `topOfTheChainContextBeforeRedirects` is a context coming from Resolver.resolve().\n  // It would contain a 'redirect' route or the first 'component' route that\n  // matched the pathname. There might be more child 'component' routes to be\n  // resolved and added into the chain. This method would find and add them.\n  // `contextBeforeRedirects` is the context containing such a child component\n  // route. It's only necessary when this method is called recursively (otherwise\n  // it's the same as the 'top of the chain' context).\n  //\n  // Apart from building the chain of child components, this method would also\n  // handle 'redirect' routes, call 'onBefore' callbacks and handle 'prevent'\n  // and 'redirect' callback results.\n  __fullyResolveChain(topOfTheChainContextBeforeRedirects,\n    contextBeforeRedirects = topOfTheChainContextBeforeRedirects) {\n    return this.__findComponentContextAfterAllRedirects(contextBeforeRedirects)\n      // `contextAfterRedirects` is always a context with an `HTMLElement` result\n      // In other cases the promise gets rejected and .then() is not called\n      .then(contextAfterRedirects => {\n        const redirectsHappened = contextAfterRedirects !== contextBeforeRedirects;\n        const topOfTheChainContextAfterRedirects =\n          redirectsHappened ? contextAfterRedirects : topOfTheChainContextBeforeRedirects;\n\n        const matchedPath = getPathnameForRouter(\n          getMatchedPath(contextAfterRedirects.chain),\n          contextAfterRedirects.resolver\n        );\n        const isFound = (matchedPath === contextAfterRedirects.pathname);\n\n        // Recursive method to try matching more child and sibling routes\n        const findNextContextIfAny = (context, parent = context.route, prevResult) => {\n          return context.next(undefined, parent, prevResult).then(nextContext => {\n            if (nextContext === null || nextContext === notFoundResult) {\n              // Next context is not found in children, ...\n              if (isFound) {\n                // ...but original context is already fully matching - use it\n                return context;\n              } else if (parent.parent !== null) {\n                // ...and there is no full match yet - step up to check siblings\n                return findNextContextIfAny(context, parent.parent, nextContext);\n              } else {\n                return nextContext;\n              }\n            }\n\n            return nextContext;\n          });\n        };\n\n        return findNextContextIfAny(contextAfterRedirects).then(nextContext => {\n          if (nextContext === null || nextContext === notFoundResult) {\n            throw getNotFoundError(topOfTheChainContextAfterRedirects);\n          }\n\n          return nextContext\n          && nextContext !== notFoundResult\n          && nextContext !== contextAfterRedirects\n            ? this.__fullyResolveChain(topOfTheChainContextAfterRedirects, nextContext)\n            : this.__amendWithOnBeforeCallbacks(contextAfterRedirects);\n        });\n      });\n  }\n\n  __findComponentContextAfterAllRedirects(context) {\n    const result = context.result;\n    if (result instanceof HTMLElement) {\n      renderElement(context, result);\n      return Promise.resolve(context);\n    } else if (result.redirect) {\n      return this.__redirect(result.redirect, context.__redirectCount, context.__renderId)\n        .then(context => this.__findComponentContextAfterAllRedirects(context));\n    } else if (result instanceof Error) {\n      return Promise.reject(result);\n    } else {\n      return Promise.reject(\n        new Error(\n          log(\n            `Invalid route resolution result for path \"${context.pathname}\". ` +\n            `Expected redirect object or HTML element, but got: \"${logValue(result)}\". ` +\n            `Double check the action return value for the route.`\n          )\n        ));\n    }\n  }\n\n  __amendWithOnBeforeCallbacks(contextWithFullChain) {\n    return this.__runOnBeforeCallbacks(contextWithFullChain).then(amendedContext => {\n      if (amendedContext === this.__previousContext || amendedContext === contextWithFullChain) {\n        return amendedContext;\n      }\n      return this.__fullyResolveChain(amendedContext);\n    });\n  }\n\n  __runOnBeforeCallbacks(newContext) {\n    const previousContext = this.__previousContext || {};\n    const previousChain = previousContext.chain || [];\n    const newChain = newContext.chain;\n\n    let callbacks = Promise.resolve();\n    const prevent = () => ({cancel: true});\n    const redirect = (pathname) => createRedirect(newContext, pathname);\n\n    newContext.__divergedChainIndex = 0;\n    newContext.__skipAttach = false;\n    if (previousChain.length) {\n      for (let i = 0; i < Math.min(previousChain.length, newChain.length); i = ++newContext.__divergedChainIndex) {\n        if (previousChain[i].route !== newChain[i].route\n          || previousChain[i].path !== newChain[i].path && previousChain[i].element !== newChain[i].element\n          || !this.__isReusableElement(previousChain[i].element, newChain[i].element)) {\n          break;\n        }\n      }\n\n      // Skip re-attaching and notifications if element and chain do not change\n      newContext.__skipAttach =\n        // Same route chain\n        newChain.length === previousChain.length && newContext.__divergedChainIndex == newChain.length &&\n        // Same element\n        this.__isReusableElement(newContext.result, previousContext.result);\n\n      if (newContext.__skipAttach) {\n        // execute onBeforeLeave for changed segment element when skipping attach\n        for (let i = newChain.length - 1; i >= 0; i--) {\n          callbacks = this.__runOnBeforeLeaveCallbacks(callbacks, newContext, {prevent}, previousChain[i]);\n        }\n        // execute onBeforeEnter for changed segment element when skipping attach\n        for (let i = 0; i < newChain.length; i++) {\n          callbacks = this.__runOnBeforeEnterCallbacks(callbacks, newContext, {prevent, redirect}, newChain[i]);\n          previousChain[i].element.location = createLocation(newContext, previousChain[i].route);\n        }\n\n      } else {\n        // execute onBeforeLeave when NOT skipping attach\n        for (let i = previousChain.length - 1; i >= newContext.__divergedChainIndex; i--) {\n          callbacks = this.__runOnBeforeLeaveCallbacks(callbacks, newContext, {prevent}, previousChain[i]);\n        }\n      }\n    }\n    // execute onBeforeEnter when NOT skipping attach\n    if (!newContext.__skipAttach) {\n      for (let i = 0; i < newChain.length; i++) {\n        if (i < newContext.__divergedChainIndex) {\n          if (i < previousChain.length && previousChain[i].element) {\n            previousChain[i].element.location = createLocation(newContext, previousChain[i].route);\n          }\n        } else {\n          callbacks = this.__runOnBeforeEnterCallbacks(callbacks, newContext, {prevent, redirect}, newChain[i]);\n          if (newChain[i].element) {\n            newChain[i].element.location = createLocation(newContext, newChain[i].route);\n          }\n        }\n      }\n    }\n    return callbacks.then(amendmentResult => {\n      if (amendmentResult) {\n        if (amendmentResult.cancel) {\n          this.__previousContext.__renderId = newContext.__renderId;\n          return this.__previousContext;\n        }\n        if (amendmentResult.redirect) {\n          return this.__redirect(amendmentResult.redirect, newContext.__redirectCount, newContext.__renderId);\n        }\n      }\n      return newContext;\n    });\n  }\n\n  __runOnBeforeLeaveCallbacks(callbacks, newContext, commands, chainElement) {\n    const location = createLocation(newContext);\n    return callbacks.then(result => {\n      if (this.__isLatestRender(newContext)) {\n        const afterLeaveFunction = amend('onBeforeLeave', [location, commands, this], chainElement.element);\n        return afterLeaveFunction(result);\n      }\n    }).then(result => {\n      if (!(result || {}).redirect) {\n        return result;\n      }\n    });\n  }\n\n  __runOnBeforeEnterCallbacks(callbacks, newContext, commands, chainElement) {\n    const location = createLocation(newContext, chainElement.route);\n    return callbacks.then(result => {\n      if (this.__isLatestRender(newContext)) {\n        const beforeEnterFunction = amend('onBeforeEnter', [location, commands, this], chainElement.element);\n        return beforeEnterFunction(result);\n      }\n    });\n  }\n\n  __isReusableElement(element, otherElement) {\n    if (element && otherElement) {\n      return this.__createdByRouter.get(element) && this.__createdByRouter.get(otherElement)\n        ? element.localName === otherElement.localName\n        : element === otherElement;\n    }\n    return false;\n  }\n\n  __isLatestRender(context) {\n    return context.__renderId === this.__lastStartedRenderId;\n  }\n\n  __redirect(redirectData, counter, renderId) {\n    if (counter > MAX_REDIRECT_COUNT) {\n      throw new Error(log(`Too many redirects when rendering ${redirectData.from}`));\n    }\n\n    return this.resolve({\n      pathname: this.urlForPath(\n        redirectData.pathname,\n        redirectData.params\n      ),\n      redirectFrom: redirectData.from,\n      __redirectCount: (counter || 0) + 1,\n      __renderId: renderId\n    });\n  }\n\n  __ensureOutlet(outlet = this.__outlet) {\n    if (!(outlet instanceof Node)) {\n      throw new TypeError(log(`Expected router outlet to be a valid DOM Node (but got ${outlet})`));\n    }\n  }\n\n  __updateBrowserHistory({pathname, search = '', hash = ''}, replace) {\n    if (window.location.pathname !== pathname\n        || window.location.search !== search\n        || window.location.hash !== hash\n    ) {\n      const changeState = replace ? 'replaceState' : 'pushState';\n      window.history[changeState](null, document.title, pathname + search + hash);\n      window.dispatchEvent(new PopStateEvent('popstate', {state: 'vaadin-router-ignore'}));\n    }\n  }\n\n  __copyUnchangedElements(context, previousContext) {\n    // Find the deepest common parent between the last and the new component\n    // chains. Update references for the unchanged elements in the new chain\n    let deepestCommonParent = this.__outlet;\n    for (let i = 0; i < context.__divergedChainIndex; i++) {\n      const unchangedElement = previousContext && previousContext.chain[i].element;\n      if (unchangedElement) {\n        if (unchangedElement.parentNode === deepestCommonParent) {\n          context.chain[i].element = unchangedElement;\n          deepestCommonParent = unchangedElement;\n        } else {\n          break;\n        }\n      }\n    }\n    return deepestCommonParent;\n  }\n\n  __addAppearingContent(context, previousContext) {\n    this.__ensureOutlet();\n\n    // If the previous 'entering' animation has not completed yet,\n    // stop it and remove that content from the DOM before adding new one.\n    this.__removeAppearingContent();\n\n    // Copy reusable elements from the previousContext to current\n    const deepestCommonParent = this.__copyUnchangedElements(context, previousContext);\n\n    // Keep two lists of DOM elements:\n    //  - those that should be removed once the transition animation is over\n    //  - and those that should remain\n    this.__appearingContent = [];\n    this.__disappearingContent = Array\n      .from(deepestCommonParent.children)\n      .filter(\n        // Only remove layout content that was added by router\n        e => this.__addedByRouter.get(e) &&\n        // Do not remove the result element to avoid flickering\n        e !== context.result);\n\n    // Add new elements (starting after the deepest common parent) to the DOM.\n    // That way only the components that are actually different between the two\n    // locations are added to the DOM (and those that are common remain in the\n    // DOM without first removing and then adding them again).\n    let parentElement = deepestCommonParent;\n    for (let i = context.__divergedChainIndex; i < context.chain.length; i++) {\n      const elementToAdd = context.chain[i].element;\n      if (elementToAdd) {\n        parentElement.appendChild(elementToAdd);\n        this.__addedByRouter.set(elementToAdd, true);\n        if (parentElement === deepestCommonParent) {\n          this.__appearingContent.push(elementToAdd);\n        }\n        parentElement = elementToAdd;\n      }\n    }\n  }\n\n  __removeDisappearingContent() {\n    if (this.__disappearingContent) {\n      removeDomNodes(this.__disappearingContent);\n    }\n    this.__disappearingContent = null;\n    this.__appearingContent = null;\n  }\n\n  __removeAppearingContent() {\n    if (this.__disappearingContent && this.__appearingContent) {\n      removeDomNodes(this.__appearingContent);\n      this.__disappearingContent = null;\n      this.__appearingContent = null;\n    }\n  }\n\n  __runOnAfterLeaveCallbacks(currentContext, targetContext) {\n    if (!targetContext) {\n      return;\n    }\n\n    // REVERSE iteration: from Z to A\n    for (let i = targetContext.chain.length - 1; i >= currentContext.__divergedChainIndex; i--) {\n      if (!this.__isLatestRender(currentContext)) {\n        break;\n      }\n      const currentComponent = targetContext.chain[i].element;\n      if (!currentComponent) {\n        continue;\n      }\n      try {\n        const location = createLocation(currentContext);\n        runCallbackIfPossible(\n          currentComponent.onAfterLeave,\n          [location, {}, targetContext.resolver],\n          currentComponent);\n      } finally {\n        if (this.__disappearingContent.indexOf(currentComponent) > -1) {\n          removeDomNodes(currentComponent.children);\n        }\n      }\n    }\n  }\n\n  __runOnAfterEnterCallbacks(currentContext) {\n    // forward iteration: from A to Z\n    for (let i = currentContext.__divergedChainIndex; i < currentContext.chain.length; i++) {\n      if (!this.__isLatestRender(currentContext)) {\n        break;\n      }\n      const currentComponent = currentContext.chain[i].element || {};\n      const location = createLocation(currentContext, currentContext.chain[i].route);\n      runCallbackIfPossible(\n        currentComponent.onAfterEnter,\n        [location, {}, currentContext.resolver],\n        currentComponent);\n    }\n  }\n\n  __animateIfNeeded(context) {\n    const from = (this.__disappearingContent || [])[0];\n    const to = (this.__appearingContent || [])[0];\n    const promises = [];\n\n    const chain = context.chain;\n    let config;\n    for (let i = chain.length; i > 0; i--) {\n      if (chain[i - 1].route.animate) {\n        config = chain[i - 1].route.animate;\n        break;\n      }\n    }\n\n    if (from && to && config) {\n      const leave = isObject(config) && config.leave || 'leaving';\n      const enter = isObject(config) && config.enter || 'entering';\n      promises.push(animate(from, leave));\n      promises.push(animate(to, enter));\n    }\n\n    return Promise.all(promises).then(() => context);\n  }\n\n  /**\n   * Subscribes this instance to navigation events on the `window`.\n   *\n   * NOTE: beware of resource leaks. For as long as a router instance is\n   * subscribed to navigation events, it won't be garbage collected.\n   */\n  subscribe() {\n    window.addEventListener('vaadin-router-go', this.__navigationEventHandler);\n  }\n\n  /**\n   * Removes the subscription to navigation events created in the `subscribe()`\n   * method.\n   */\n  unsubscribe() {\n    window.removeEventListener('vaadin-router-go', this.__navigationEventHandler);\n  }\n\n  __onNavigationEvent(event) {\n    const {pathname, search, hash} = event ? event.detail : window.location;\n    if (isString(this.__normalizePathname(pathname))) {\n      if (event && event.preventDefault) {\n        event.preventDefault();\n      }\n      this.render({pathname, search, hash}, true);\n    }\n  }\n\n  /**\n   * Configures what triggers Router navigation events:\n   *  - `POPSTATE`: popstate events on the current `window`\n   *  - `CLICK`: click events on `<a>` links leading to the current page\n   *\n   * This method is invoked with the pre-configured values when creating a new Router instance.\n   * By default, both `POPSTATE` and `CLICK` are enabled. This setup is expected to cover most of the use cases.\n   *\n   * See the `router-config.js` for the default navigation triggers config. Based on it, you can\n   * create the own one and only import the triggers you need, instead of pulling in all the code,\n   * e.g. if you want to handle `click` differently.\n   *\n   * See also **Navigation Triggers** section in [Live Examples](#/classes/Router/demos/demo/index.html).\n   *\n   * @param {...NavigationTrigger} triggers\n   */\n  static setTriggers(...triggers) {\n    setNavigationTriggers(triggers);\n  }\n\n  /**\n   * Generates a URL for the route with the given name, optionally performing\n   * substitution of parameters.\n   *\n   * The route is searched in all the Router instances subscribed to\n   * navigation events.\n   *\n   * **Note:** For child route names, only array children are considered.\n   * It is not possible to generate URLs using a name for routes set with\n   * a children function.\n   *\n   * @function urlForName\n   * @param {!string} name the route name or the route’s `component` name.\n   * @param {Params=} params Optional object with route path parameters.\n   * Named parameters are passed by name (`params[name] = value`), unnamed\n   * parameters are passed by index (`params[index] = value`).\n   *\n   * @return {string}\n   */\n  urlForName(name, params) {\n    if (!this.__urlForName) {\n      this.__urlForName = generateUrls(this);\n    }\n    return getPathnameForRouter(\n      this.__urlForName(name, params),\n      this\n    );\n  }\n\n  /**\n   * Generates a URL for the given route path, optionally performing\n   * substitution of parameters.\n   *\n   * @param {!string} path string route path declared in [express.js syntax](https://expressjs.com/en/guide/routing.html#route-paths\").\n   * @param {Params=} params Optional object with route path parameters.\n   * Named parameters are passed by name (`params[name] = value`), unnamed\n   * parameters are passed by index (`params[index] = value`).\n   *\n   * @return {string}\n   */\n  urlForPath(path, params) {\n    return getPathnameForRouter(\n      Router.pathToRegexp.compile(path)(params),\n      this\n    );\n  }\n\n  /**\n   * Triggers navigation to a new path. Returns a boolean without waiting until\n   * the navigation is complete. Returns `true` if at least one `Router`\n   * has handled the navigation (was subscribed and had `baseUrl` matching\n   * the `path` argument), otherwise returns `false`.\n   *\n   * @param {!string|!{pathname: !string, search: (string|undefined), hash: (string|undefined)}} path\n   *   a new in-app path string, or an URL-like object with `pathname`\n   *   string property, and optional `search` and `hash` string properties.\n   * @return {boolean}\n   */\n  static go(path) {\n    const {pathname, search, hash} = isString(path)\n      ? this.__createUrl(path, 'http://a') // some base to omit origin\n      : path;\n    return fireRouterEvent('go', {pathname, search, hash});\n  }\n}\n\nconst DEV_MODE_CODE_REGEXP =\n  /\\/\\*\\*\\s+vaadin-dev-mode:start([\\s\\S]*)vaadin-dev-mode:end\\s+\\*\\*\\//i;\n\nconst FlowClients = window.Vaadin && window.Vaadin.Flow && window.Vaadin.Flow.clients;\n\nfunction isMinified() {\n  function test() {\n    /** vaadin-dev-mode:start\n    return false;\n    vaadin-dev-mode:end **/\n    return true;\n  }\n  return uncommentAndRun(test);\n}\n\nfunction isDevelopmentMode() {\n  try {\n    if (isForcedDevelopmentMode()) {\n      return true;\n    }\n\n    if (!isLocalhost()) {\n      return false;\n    }\n\n    if (FlowClients) {\n      return !isFlowProductionMode();\n    }\n\n    return !isMinified();\n  } catch (e) {\n    // Some error in this code, assume production so no further actions will be taken\n    return false;\n  }\n}\n\nfunction isForcedDevelopmentMode() {\n  return localStorage.getItem(\"vaadin.developmentmode.force\");\n}\n\nfunction isLocalhost() {\n  return ([\"localhost\",\"127.0.0.1\"].indexOf(window.location.hostname) >= 0);\n}\n\nfunction isFlowProductionMode() {\n  if (FlowClients) {\n    const productionModeApps = Object.keys(FlowClients)\n      .map(key => FlowClients[key])\n      .filter(client => client.productionMode);\n    if (productionModeApps.length > 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction uncommentAndRun(callback, args) {\n  if (typeof callback !== 'function') {\n    return;\n  }\n\n  const match = DEV_MODE_CODE_REGEXP.exec(callback.toString());\n  if (match) {\n    try {\n      // requires CSP: script-src 'unsafe-eval'\n      callback = new Function(match[1]);\n    } catch (e) {\n      // eat the exception\n      console.log('vaadin-development-mode-detector: uncommentAndRun() failed', e);\n    }\n  }\n\n  return callback(args);\n}\n\n// A guard against polymer-modulizer removing the window.Vaadin\n// initialization above.\nwindow['Vaadin'] = window['Vaadin'] || {};\n\n/**\n * Inspects the source code of the given `callback` function for\n * specially-marked _commented_ code. If such commented code is found in the\n * callback source, uncomments and runs that code instead of the callback\n * itself. Otherwise runs the callback as is.\n *\n * The optional arguments are passed into the callback / uncommented code,\n * the result is returned.\n *\n * See the `isMinified()` function source code in this file for an example.\n *\n */\nconst runIfDevelopmentMode = function(callback, args) {\n  if (window.Vaadin.developmentMode) {\n    return uncommentAndRun(callback, args);\n  }\n};\n\nif (window.Vaadin.developmentMode === undefined) {\n  window.Vaadin.developmentMode = isDevelopmentMode();\n}\n\n/* This file is autogenerated from src/vaadin-usage-statistics.tpl.html */\n\nfunction maybeGatherAndSendStats() {\n  /** vaadin-dev-mode:start\n  (function () {\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar getPolymerVersion = function getPolymerVersion() {\n  return window.Polymer && window.Polymer.version;\n};\n\nvar StatisticsGatherer = function () {\n  function StatisticsGatherer(logger) {\n    classCallCheck(this, StatisticsGatherer);\n\n    this.now = new Date().getTime();\n    this.logger = logger;\n  }\n\n  createClass(StatisticsGatherer, [{\n    key: 'frameworkVersionDetectors',\n    value: function frameworkVersionDetectors() {\n      return {\n        'Flow': function Flow() {\n          if (window.Vaadin && window.Vaadin.Flow && window.Vaadin.Flow.clients) {\n            var flowVersions = Object.keys(window.Vaadin.Flow.clients).map(function (key) {\n              return window.Vaadin.Flow.clients[key];\n            }).filter(function (client) {\n              return client.getVersionInfo;\n            }).map(function (client) {\n              return client.getVersionInfo().flow;\n            });\n            if (flowVersions.length > 0) {\n              return flowVersions[0];\n            }\n          }\n        },\n        'Vaadin Framework': function VaadinFramework() {\n          if (window.vaadin && window.vaadin.clients) {\n            var frameworkVersions = Object.values(window.vaadin.clients).filter(function (client) {\n              return client.getVersionInfo;\n            }).map(function (client) {\n              return client.getVersionInfo().vaadinVersion;\n            });\n            if (frameworkVersions.length > 0) {\n              return frameworkVersions[0];\n            }\n          }\n        },\n        'AngularJs': function AngularJs() {\n          if (window.angular && window.angular.version && window.angular.version) {\n            return window.angular.version.full;\n          }\n        },\n        'Angular': function Angular() {\n          if (window.ng) {\n            var tags = document.querySelectorAll(\"[ng-version]\");\n            if (tags.length > 0) {\n              return tags[0].getAttribute(\"ng-version\");\n            }\n            return \"Unknown\";\n          }\n        },\n        'Backbone.js': function BackboneJs() {\n          if (window.Backbone) {\n            return window.Backbone.VERSION;\n          }\n        },\n        'React': function React() {\n          var reactSelector = '[data-reactroot], [data-reactid]';\n          if (!!document.querySelector(reactSelector)) {\n            // React does not publish the version by default\n            return \"unknown\";\n          }\n        },\n        'Ember': function Ember() {\n          if (window.Em && window.Em.VERSION) {\n            return window.Em.VERSION;\n          } else if (window.Ember && window.Ember.VERSION) {\n            return window.Ember.VERSION;\n          }\n        },\n        'jQuery': function (_jQuery) {\n          function jQuery() {\n            return _jQuery.apply(this, arguments);\n          }\n\n          jQuery.toString = function () {\n            return _jQuery.toString();\n          };\n\n          return jQuery;\n        }(function () {\n          if (typeof jQuery === 'function' && jQuery.prototype.jquery !== undefined) {\n            return jQuery.prototype.jquery;\n          }\n        }),\n        'Polymer': function Polymer() {\n          var version = getPolymerVersion();\n          if (version) {\n            return version;\n          }\n        },\n        'LitElement': function LitElement() {\n          var version = window.litElementVersions && window.litElementVersions[0];\n          if (version) {\n            return version;\n          }\n        },\n        'LitHtml': function LitHtml() {\n          var version = window.litHtmlVersions && window.litHtmlVersions[0];\n          if (version) {\n            return version;\n          }\n        },\n        'Vue.js': function VueJs() {\n          if (window.Vue) {\n            return window.Vue.version;\n          }\n        }\n      };\n    }\n  }, {\n    key: 'getUsedVaadinElements',\n    value: function getUsedVaadinElements(elements) {\n      var version = getPolymerVersion();\n      var elementClasses = void 0;\n      // NOTE: In case you edit the code here, YOU MUST UPDATE any statistics reporting code in Flow.\n      // Check all locations calling the method getEntries() in\n      // https://github.com/vaadin/flow/blob/master/flow-server/src/main/java/com/vaadin/flow/internal/UsageStatistics.java#L106\n      // Currently it is only used by BootstrapHandler.\n      if (version && version.indexOf('2') === 0) {\n        // Polymer 2: components classes are stored in window.Vaadin\n        elementClasses = Object.keys(window.Vaadin).map(function (c) {\n          return window.Vaadin[c];\n        }).filter(function (c) {\n          return c.is;\n        });\n      } else {\n        // Polymer 3: components classes are stored in window.Vaadin.registrations\n        elementClasses = window.Vaadin.registrations || [];\n      }\n      elementClasses.forEach(function (klass) {\n        var version = klass.version ? klass.version : \"0.0.0\";\n        elements[klass.is] = { version: version };\n      });\n    }\n  }, {\n    key: 'getUsedVaadinThemes',\n    value: function getUsedVaadinThemes(themes) {\n      ['Lumo', 'Material'].forEach(function (themeName) {\n        var theme;\n        var version = getPolymerVersion();\n        if (version && version.indexOf('2') === 0) {\n          // Polymer 2: themes are stored in window.Vaadin\n          theme = window.Vaadin[themeName];\n        } else {\n          // Polymer 3: themes are stored in custom element registry\n          theme = customElements.get('vaadin-' + themeName.toLowerCase() + '-styles');\n        }\n        if (theme && theme.version) {\n          themes[themeName] = { version: theme.version };\n        }\n      });\n    }\n  }, {\n    key: 'getFrameworks',\n    value: function getFrameworks(frameworks) {\n      var detectors = this.frameworkVersionDetectors();\n      Object.keys(detectors).forEach(function (framework) {\n        var detector = detectors[framework];\n        try {\n          var version = detector();\n          if (version) {\n            frameworks[framework] = { version: version };\n          }\n        } catch (e) {}\n      });\n    }\n  }, {\n    key: 'gather',\n    value: function gather(storage) {\n      var storedStats = storage.read();\n      var gatheredStats = {};\n      var types = [\"elements\", \"frameworks\", \"themes\"];\n\n      types.forEach(function (type) {\n        gatheredStats[type] = {};\n        if (!storedStats[type]) {\n          storedStats[type] = {};\n        }\n      });\n\n      var previousStats = JSON.stringify(storedStats);\n\n      this.getUsedVaadinElements(gatheredStats.elements);\n      this.getFrameworks(gatheredStats.frameworks);\n      this.getUsedVaadinThemes(gatheredStats.themes);\n\n      var now = this.now;\n      types.forEach(function (type) {\n        var keys = Object.keys(gatheredStats[type]);\n        keys.forEach(function (key) {\n          if (!storedStats[type][key] || _typeof(storedStats[type][key]) != _typeof({})) {\n            storedStats[type][key] = { firstUsed: now };\n          }\n          // Discards any previously logged version number\n          storedStats[type][key].version = gatheredStats[type][key].version;\n          storedStats[type][key].lastUsed = now;\n        });\n      });\n\n      var newStats = JSON.stringify(storedStats);\n      storage.write(newStats);\n      if (newStats != previousStats && Object.keys(storedStats).length > 0) {\n        this.logger.debug(\"New stats: \" + newStats);\n      }\n    }\n  }]);\n  return StatisticsGatherer;\n}();\n\nvar StatisticsStorage = function () {\n  function StatisticsStorage(key) {\n    classCallCheck(this, StatisticsStorage);\n\n    this.key = key;\n  }\n\n  createClass(StatisticsStorage, [{\n    key: 'read',\n    value: function read() {\n      var localStorageStatsString = localStorage.getItem(this.key);\n      try {\n        return JSON.parse(localStorageStatsString ? localStorageStatsString : '{}');\n      } catch (e) {\n        return {};\n      }\n    }\n  }, {\n    key: 'write',\n    value: function write(data) {\n      localStorage.setItem(this.key, data);\n    }\n  }, {\n    key: 'clear',\n    value: function clear() {\n      localStorage.removeItem(this.key);\n    }\n  }, {\n    key: 'isEmpty',\n    value: function isEmpty() {\n      var storedStats = this.read();\n      var empty = true;\n      Object.keys(storedStats).forEach(function (key) {\n        if (Object.keys(storedStats[key]).length > 0) {\n          empty = false;\n        }\n      });\n\n      return empty;\n    }\n  }]);\n  return StatisticsStorage;\n}();\n\nvar StatisticsSender = function () {\n  function StatisticsSender(url, logger) {\n    classCallCheck(this, StatisticsSender);\n\n    this.url = url;\n    this.logger = logger;\n  }\n\n  createClass(StatisticsSender, [{\n    key: 'send',\n    value: function send(data, errorHandler) {\n      var logger = this.logger;\n\n      if (navigator.onLine === false) {\n        logger.debug(\"Offline, can't send\");\n        errorHandler();\n        return;\n      }\n      logger.debug(\"Sending data to \" + this.url);\n\n      var req = new XMLHttpRequest();\n      req.withCredentials = true;\n      req.addEventListener(\"load\", function () {\n        // Stats sent, nothing more to do\n        logger.debug(\"Response: \" + req.responseText);\n      });\n      req.addEventListener(\"error\", function () {\n        logger.debug(\"Send failed\");\n        errorHandler();\n      });\n      req.addEventListener(\"abort\", function () {\n        logger.debug(\"Send aborted\");\n        errorHandler();\n      });\n      req.open(\"POST\", this.url);\n      req.setRequestHeader(\"Content-Type\", \"application/json\");\n      req.send(data);\n    }\n  }]);\n  return StatisticsSender;\n}();\n\nvar StatisticsLogger = function () {\n  function StatisticsLogger(id) {\n    classCallCheck(this, StatisticsLogger);\n\n    this.id = id;\n  }\n\n  createClass(StatisticsLogger, [{\n    key: '_isDebug',\n    value: function _isDebug() {\n      return localStorage.getItem(\"vaadin.\" + this.id + \".debug\");\n    }\n  }, {\n    key: 'debug',\n    value: function debug(msg) {\n      if (this._isDebug()) {\n        console.info(this.id + \": \" + msg);\n      }\n    }\n  }]);\n  return StatisticsLogger;\n}();\n\nvar UsageStatistics = function () {\n  function UsageStatistics() {\n    classCallCheck(this, UsageStatistics);\n\n    this.now = new Date();\n    this.timeNow = this.now.getTime();\n    this.gatherDelay = 10; // Delay between loading this file and gathering stats\n    this.initialDelay = 24 * 60 * 60;\n\n    this.logger = new StatisticsLogger(\"statistics\");\n    this.storage = new StatisticsStorage(\"vaadin.statistics.basket\");\n    this.gatherer = new StatisticsGatherer(this.logger);\n    this.sender = new StatisticsSender(\"https://tools.vaadin.com/usage-stats/submit\", this.logger);\n  }\n\n  createClass(UsageStatistics, [{\n    key: 'maybeGatherAndSend',\n    value: function maybeGatherAndSend() {\n      var _this = this;\n\n      if (localStorage.getItem(UsageStatistics.optOutKey)) {\n        return;\n      }\n      this.gatherer.gather(this.storage);\n      setTimeout(function () {\n        _this.maybeSend();\n      }, this.gatherDelay * 1000);\n    }\n  }, {\n    key: 'lottery',\n    value: function lottery() {\n      return true;\n    }\n  }, {\n    key: 'currentMonth',\n    value: function currentMonth() {\n      return this.now.getYear() * 12 + this.now.getMonth();\n    }\n  }, {\n    key: 'maybeSend',\n    value: function maybeSend() {\n      var firstUse = Number(localStorage.getItem(UsageStatistics.firstUseKey));\n      var monthProcessed = Number(localStorage.getItem(UsageStatistics.monthProcessedKey));\n\n      if (!firstUse) {\n        // Use a grace period to avoid interfering with tests, incognito mode etc\n        firstUse = this.timeNow;\n        localStorage.setItem(UsageStatistics.firstUseKey, firstUse);\n      }\n\n      if (this.timeNow < firstUse + this.initialDelay * 1000) {\n        this.logger.debug(\"No statistics will be sent until the initial delay of \" + this.initialDelay + \"s has passed\");\n        return;\n      }\n      if (this.currentMonth() <= monthProcessed) {\n        this.logger.debug(\"This month has already been processed\");\n        return;\n      }\n      localStorage.setItem(UsageStatistics.monthProcessedKey, this.currentMonth());\n      // Use random sampling\n      if (this.lottery()) {\n        this.logger.debug(\"Congratulations, we have a winner!\");\n      } else {\n        this.logger.debug(\"Sorry, no stats from you this time\");\n        return;\n      }\n\n      this.send();\n    }\n  }, {\n    key: 'send',\n    value: function send() {\n      // Ensure we have the latest data\n      this.gatherer.gather(this.storage);\n\n      // Read, send and clean up\n      var data = this.storage.read();\n      data[\"firstUse\"] = Number(localStorage.getItem(UsageStatistics.firstUseKey));\n      data[\"usageStatisticsVersion\"] = UsageStatistics.version;\n      var info = 'This request contains usage statistics gathered from the application running in development mode. \\n\\nStatistics gathering is automatically disabled and excluded from production builds.\\n\\nFor details and to opt-out, see https://github.com/vaadin/vaadin-usage-statistics.\\n\\n\\n\\n';\n      var self = this;\n      this.sender.send(info + JSON.stringify(data), function () {\n        // Revert the 'month processed' flag\n        localStorage.setItem(UsageStatistics.monthProcessedKey, self.currentMonth() - 1);\n      });\n    }\n  }], [{\n    key: 'version',\n    get: function get$1() {\n      return '2.1.0';\n    }\n  }, {\n    key: 'firstUseKey',\n    get: function get$1() {\n      return 'vaadin.statistics.firstuse';\n    }\n  }, {\n    key: 'monthProcessedKey',\n    get: function get$1() {\n      return 'vaadin.statistics.monthProcessed';\n    }\n  }, {\n    key: 'optOutKey',\n    get: function get$1() {\n      return 'vaadin.statistics.optout';\n    }\n  }]);\n  return UsageStatistics;\n}();\n\ntry {\n  window.Vaadin = window.Vaadin || {};\n  window.Vaadin.usageStatsChecker = window.Vaadin.usageStatsChecker || new UsageStatistics();\n  window.Vaadin.usageStatsChecker.maybeGatherAndSend();\n} catch (e) {\n  // Intentionally ignored as this is not a problem in the app being developed\n}\n\n}());\n\n  vaadin-dev-mode:end **/\n}\n\nconst usageStatistics = function() {\n  if (typeof runIfDevelopmentMode === 'function') {\n    return runIfDevelopmentMode(maybeGatherAndSendStats);\n  }\n};\n\nwindow.Vaadin = window.Vaadin || {};\nwindow.Vaadin.registrations = window.Vaadin.registrations || [];\n\nwindow.Vaadin.registrations.push({\n  is: '@vaadin/router',\n  version: '1.7.4',\n});\n\nusageStatistics();\n\nRouter.NavigationTrigger = {POPSTATE, CLICK};\n\nexport { Router };\n", "var umap = _ => ({\n  // About: get: _.get.bind(_)\n  // It looks like WebKit/Safari didn't optimize bind at all,\n  // so that using bind slows it down by 60%.\n  // Firefox and Chrome are just fine in both cases,\n  // so let's use the approach that works fast everywhere 👍\n  get: key => _.get(key),\n  set: (key, value) => (_.set(key, value), value)\n});\n\nconst attr = /([^\\s\\\\>\"'=]+)\\s*=\\s*(['\"]?)$/;\nconst empty = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;\nconst node = /<[a-z][^>]+$/i;\nconst notNode = />[^<>]*$/;\nconst selfClosing = /<([a-z]+[a-z0-9:._-]*)([^>]*?)(\\/>)/ig;\nconst trimEnd = /\\s+$/;\n\nconst isNode = (template, i) => (\n    0 < i-- && (\n    node.test(template[i]) || (\n      !notNode.test(template[i]) && isNode(template, i)\n    )\n  )\n);\n\nconst regular = (original, name, extra) => empty.test(name) ?\n                  original : `<${name}${extra.replace(trimEnd,'')}></${name}>`;\n\nvar instrument = (template, prefix, svg) => {\n  const text = [];\n  const {length} = template;\n  for (let i = 1; i < length; i++) {\n    const chunk = template[i - 1];\n    text.push(attr.test(chunk) && isNode(template, i) ?\n      chunk.replace(\n        attr,\n        (_, $1, $2) => `${prefix}${i - 1}=${$2 || '\"'}${$1}${$2 ? '' : '\"'}`\n      ) :\n      `${chunk}<!--${prefix}${i - 1}-->`\n    );\n  }\n  text.push(template[length - 1]);\n  const output = text.join('').trim();\n  return svg ? output : output.replace(selfClosing, regular);\n};\n\nconst {isArray} = Array;\nconst {indexOf, slice} = [];\n\nconst ELEMENT_NODE = 1;\nconst nodeType = 111;\n\nconst remove = ({firstChild, lastChild}) => {\n  const range = document.createRange();\n  range.setStartAfter(firstChild);\n  range.setEndAfter(lastChild);\n  range.deleteContents();\n  return firstChild;\n};\n\nconst diffable = (node, operation) => node.nodeType === nodeType ?\n  ((1 / operation) < 0 ?\n    (operation ? remove(node) : node.lastChild) :\n    (operation ? node.valueOf() : node.firstChild)) :\n  node\n;\n\nconst persistent = fragment => {\n  const {childNodes} = fragment;\n  const {length} = childNodes;\n  if (length < 2)\n    return length ? childNodes[0] : fragment;\n  const nodes = slice.call(childNodes, 0);\n  const firstChild = nodes[0];\n  const lastChild = nodes[length - 1];\n  return {\n    ELEMENT_NODE,\n    nodeType,\n    firstChild,\n    lastChild,\n    valueOf() {\n      if (childNodes.length !== length) {\n        let i = 0;\n        while (i < length)\n          fragment.appendChild(nodes[i++]);\n      }\n      return fragment;\n    }\n  };\n};\n\n/**\n * ISC License\n *\n * Copyright (c) 2020, Andrea Giammarchi, @WebReflection\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/**\n * @param {Node} parentNode The container where children live\n * @param {Node[]} a The list of current/live children\n * @param {Node[]} b The list of future children\n * @param {(entry: Node, action: number) => Node} get\n * The callback invoked per each entry related DOM operation.\n * @param {Node} [before] The optional node used as anchor to insert before.\n * @returns {Node[]} The same list of future children.\n */\nvar udomdiff = (parentNode, a, b, get, before) => {\n  const bLength = b.length;\n  let aEnd = a.length;\n  let bEnd = bLength;\n  let aStart = 0;\n  let bStart = 0;\n  let map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    // append head, tail, or nodes in between: fast path\n    if (aEnd === aStart) {\n      // we could be in a situation where the rest of nodes that\n      // need to be added are not at the end, and in such case\n      // the node to `insertBefore`, if the index is more than 0\n      // must be retrieved, otherwise it's gonna be the first item.\n      const node = bEnd < bLength ?\n        (bStart ?\n          (get(b[bStart - 1], -0).nextSibling) :\n          get(b[bEnd - bStart], 0)) :\n        before;\n      while (bStart < bEnd)\n        parentNode.insertBefore(get(b[bStart++], 1), node);\n    }\n    // remove head or tail: fast path\n    else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        // remove the node only if it's unknown or not live\n        if (!map || !map.has(a[aStart]))\n          parentNode.removeChild(get(a[aStart], -1));\n        aStart++;\n      }\n    }\n    // same node: fast path\n    else if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n    }\n    // same tail: fast path\n    else if (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    // The once here single last swap \"fast path\" has been removed in v1.1.0\n    // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85\n    // reverse swap: also fast path\n    else if (\n      a[aStart] === b[bEnd - 1] &&\n      b[bStart] === a[aEnd - 1]\n    ) {\n      // this is a \"shrink\" operation that could happen in these cases:\n      // [1, 2, 3, 4, 5]\n      // [1, 4, 3, 2, 5]\n      // or asymmetric too\n      // [1, 2, 3, 4, 5]\n      // [1, 2, 3, 5, 6, 4]\n      const node = get(a[--aEnd], -1).nextSibling;\n      parentNode.insertBefore(\n        get(b[bStart++], 1),\n        get(a[aStart++], -1).nextSibling\n      );\n      parentNode.insertBefore(get(b[--bEnd], 1), node);\n      // mark the future index as identical (yeah, it's dirty, but cheap 👍)\n      // The main reason to do this, is that when a[aEnd] will be reached,\n      // the loop will likely be on the fast path, as identical to b[bEnd].\n      // In the best case scenario, the next loop will skip the tail,\n      // but in the worst one, this node will be considered as already\n      // processed, bailing out pretty quickly from the map index check\n      a[aEnd] = b[bEnd];\n    }\n    // map based fallback, \"slow\" path\n    else {\n      // the map requires an O(bEnd - bStart) operation once\n      // to store all future nodes indexes for later purposes.\n      // In the worst case scenario, this is a full O(N) cost,\n      // and such scenario happens at least when all nodes are different,\n      // but also if both first and last items of the lists are different\n      if (!map) {\n        map = new Map;\n        let i = bStart;\n        while (i < bEnd)\n          map.set(b[i], i++);\n      }\n      // if it's a future node, hence it needs some handling\n      if (map.has(a[aStart])) {\n        // grab the index of such node, 'cause it might have been processed\n        const index = map.get(a[aStart]);\n        // if it's not already processed, look on demand for the next LCS\n        if (bStart < index && index < bEnd) {\n          let i = aStart;\n          // counts the amount of nodes that are the same in the future\n          let sequence = 1;\n          while (++i < aEnd && i < bEnd && map.get(a[i]) === (index + sequence))\n            sequence++;\n          // effort decision here: if the sequence is longer than replaces\n          // needed to reach such sequence, which would brings again this loop\n          // to the fast path, prepend the difference before a sequence,\n          // and move only the future list index forward, so that aStart\n          // and bStart will be aligned again, hence on the fast path.\n          // An example considering aStart and bStart are both 0:\n          // a: [1, 2, 3, 4]\n          // b: [7, 1, 2, 3, 6]\n          // this would place 7 before 1 and, from that time on, 1, 2, and 3\n          // will be processed at zero cost\n          if (sequence > (index - bStart)) {\n            const node = get(a[aStart], 0);\n            while (bStart < index)\n              parentNode.insertBefore(get(b[bStart++], 1), node);\n          }\n          // if the effort wasn't good enough, fallback to a replace,\n          // moving both source and target indexes forward, hoping that some\n          // similar node will be found later on, to go back to the fast path\n          else {\n            parentNode.replaceChild(\n              get(b[bStart++], 1),\n              get(a[aStart++], -1)\n            );\n          }\n        }\n        // otherwise move the source forward, 'cause there's nothing to do\n        else\n          aStart++;\n      }\n      // this node has no meaning in the future list, so it's more than safe\n      // to remove it, and check the next live node out instead, meaning\n      // that only the live list index should be forwarded\n      else\n        parentNode.removeChild(get(a[aStart++], -1));\n    }\n  }\n  return b;\n};\n\nconst aria = node => values => {\n  for (const key in values) {\n    const name = key === 'role' ? key : `aria-${key}`;\n    const value = values[key];\n    if (value == null)\n      node.removeAttribute(name);\n    else\n      node.setAttribute(name, value);\n  }\n};\n\nconst attribute = (node, name) => {\n  let oldValue, orphan = true;\n  const attributeNode = document.createAttributeNS(null, name);\n  return newValue => {\n    if (oldValue !== newValue) {\n      oldValue = newValue;\n      if (oldValue == null) {\n        if (!orphan) {\n          node.removeAttributeNode(attributeNode);\n          orphan = true;\n        }\n      }\n      else {\n        attributeNode.value = newValue;\n        if (orphan) {\n          node.setAttributeNodeNS(attributeNode);\n          orphan = false;\n        }\n      }\n    }\n  };\n};\n\nconst boolean = (node, key, oldValue) => newValue => {\n  if (oldValue !== !!newValue) {\n    // when IE won't be around anymore ...\n    // node.toggleAttribute(key, oldValue = !!newValue);\n    if ((oldValue = !!newValue))\n      node.setAttribute(key, '');\n    else\n      node.removeAttribute(key);\n  }\n};\n\nconst data = ({dataset}) => values => {\n  for (const key in values) {\n    const value = values[key];\n    if (value == null)\n      delete dataset[key];\n    else\n      dataset[key] = value;\n  }\n};\n\nconst event = (node, name) => {\n  let oldValue, type = name.slice(2);\n  if (!(name in node) && name.toLowerCase() in node)\n    type = type.toLowerCase();\n  return newValue => {\n    const info = isArray(newValue) ? newValue : [newValue, false];\n    if (oldValue !== info[0]) {\n      if (oldValue)\n        node.removeEventListener(type, oldValue, info[1]);\n      if (oldValue = info[0])\n        node.addEventListener(type, oldValue, info[1]);\n    }\n  };\n};\n\nconst ref = node => {\n  let oldValue;\n  return value => {\n    if (oldValue !== value) {\n      oldValue = value;\n      if (typeof value === 'function')\n        value(node);\n      else\n        value.current = node;\n    }\n  };\n};\n\nconst setter = (node, key) => key === 'dataset' ?\n  data(node) :\n  value => {\n    node[key] = value;\n  };\n\nconst text = node => {\n  let oldValue;\n  return newValue => {\n    if (oldValue != newValue) {\n      oldValue = newValue;\n      node.textContent = newValue == null ? '' : newValue;\n    }\n  };\n};\n\n// from a generic path, retrieves the exact targeted node\nconst reducePath = ({childNodes}, i) => childNodes[i];\n\n// this helper avoid code bloat around handleAnything() callback\nconst diff = (comment, oldNodes, newNodes) => udomdiff(\n  comment.parentNode,\n  // TODO: there is a possible edge case where a node has been\n  //       removed manually, or it was a keyed one, attached\n  //       to a shared reference between renders.\n  //       In this case udomdiff might fail at removing such node\n  //       as its parent won't be the expected one.\n  //       The best way to avoid this issue is to filter oldNodes\n  //       in search of those not live, or not in the current parent\n  //       anymore, but this would require both a change to uwire,\n  //       exposing a parentNode from the firstChild, as example,\n  //       but also a filter per each diff that should exclude nodes\n  //       that are not in there, penalizing performance quite a lot.\n  //       As this has been also a potential issue with domdiff,\n  //       and both lighterhtml and hyperHTML might fail with this\n  //       very specific edge case, I might as well document this possible\n  //       \"diffing shenanigan\" and call it a day.\n  oldNodes,\n  newNodes,\n  diffable,\n  comment\n);\n\n// if an interpolation represents a comment, the whole\n// diffing will be related to such comment.\n// This helper is in charge of understanding how the new\n// content for such interpolation/hole should be updated\nconst handleAnything = comment => {\n  let oldValue, text, nodes = [];\n  const anyContent = newValue => {\n    switch (typeof newValue) {\n      // primitives are handled as text content\n      case 'string':\n      case 'number':\n      case 'boolean':\n        if (oldValue !== newValue) {\n          oldValue = newValue;\n          if (!text)\n            text = document.createTextNode('');\n          text.data = newValue;\n          nodes = diff(comment, nodes, [text]);\n        }\n        break;\n      // null, and undefined are used to cleanup previous content\n      case 'object':\n      case 'undefined':\n        if (newValue == null) {\n          if (oldValue != newValue) {\n            oldValue = newValue;\n            nodes = diff(comment, nodes, []);\n          }\n          break;\n        }\n        // arrays and nodes have a special treatment\n        if (isArray(newValue)) {\n          oldValue = newValue;\n          // arrays can be used to cleanup, if empty\n          if (newValue.length === 0)\n            nodes = diff(comment, nodes, []);\n          // or diffed, if these contains nodes or \"wires\"\n          else if (typeof newValue[0] === 'object')\n            nodes = diff(comment, nodes, newValue);\n          // in all other cases the content is stringified as is\n          else\n            anyContent(String(newValue));\n          break;\n        }\n        // if the new value is a DOM node, or a wire, and it's\n        // different from the one already live, then it's diffed.\n        // if the node is a fragment, it's appended once via its childNodes\n        // There is no `else` here, meaning if the content\n        // is not expected one, nothing happens, as easy as that.\n        if (oldValue !== newValue && 'ELEMENT_NODE' in newValue) {\n          oldValue = newValue;\n          nodes = diff(\n            comment,\n            nodes,\n            newValue.nodeType === 11 ?\n              slice.call(newValue.childNodes) :\n              [newValue]\n          );\n        }\n        break;\n      case 'function':\n        anyContent(newValue(comment));\n        break;\n    }\n  };\n  return anyContent;\n};\n\n// attributes can be:\n//  * ref=${...}      for hooks and other purposes\n//  * aria=${...}     for aria attributes\n//  * ?boolean=${...} for boolean attributes\n//  * .dataset=${...} for dataset related attributes\n//  * .setter=${...}  for Custom Elements setters or nodes with setters\n//                    such as buttons, details, options, select, etc\n//  * @event=${...}   to explicitly handle event listeners\n//  * onevent=${...}  to automatically handle event listeners\n//  * generic=${...}  to handle an attribute just like an attribute\nconst handleAttribute = (node, name/*, svg*/) => {\n  switch (name[0]) {\n    case '?': return boolean(node, name.slice(1), false);\n    case '.': return setter(node, name.slice(1));\n    case '@': return event(node, 'on' + name.slice(1));\n    case 'o': if (name[1] === 'n') return event(node, name);\n  }\n\n  switch (name) {\n    case 'ref': return ref(node);\n    case 'aria': return aria(node);\n  }\n\n  return attribute(node, name/*, svg*/);\n};\n\n// each mapped update carries the update type and its path\n// the type is either node, attribute, or text, while\n// the path is how to retrieve the related node to update.\n// In the attribute case, the attribute name is also carried along.\nfunction handlers(options) {\n  const {type, path} = options;\n  const node = path.reduceRight(reducePath, this);\n  return type === 'node' ?\n    handleAnything(node) :\n    (type === 'attr' ?\n      handleAttribute(node, options.name/*, options.svg*/) :\n      text(node));\n}\n\n/*! (c) Andrea Giammarchi - ISC */\nvar createContent = (function (document) {  var FRAGMENT = 'fragment';\n  var TEMPLATE = 'template';\n  var HAS_CONTENT = 'content' in create(TEMPLATE);\n\n  var createHTML = HAS_CONTENT ?\n    function (html) {\n      var template = create(TEMPLATE);\n      template.innerHTML = html;\n      return template.content;\n    } :\n    function (html) {\n      var content = create(FRAGMENT);\n      var template = create(TEMPLATE);\n      var childNodes = null;\n      if (/^[^\\S]*?<(col(?:group)?|t(?:head|body|foot|r|d|h))/i.test(html)) {\n        var selector = RegExp.$1;\n        template.innerHTML = '<table>' + html + '</table>';\n        childNodes = template.querySelectorAll(selector);\n      } else {\n        template.innerHTML = html;\n        childNodes = template.childNodes;\n      }\n      append(content, childNodes);\n      return content;\n    };\n\n  return function createContent(markup, type) {\n    return (type === 'svg' ? createSVG : createHTML)(markup);\n  };\n\n  function append(root, childNodes) {\n    var length = childNodes.length;\n    while (length--)\n      root.appendChild(childNodes[0]);\n  }\n\n  function create(element) {\n    return element === FRAGMENT ?\n      document.createDocumentFragment() :\n      document.createElementNS('http://www.w3.org/1999/xhtml', element);\n  }\n\n  // it could use createElementNS when hasNode is there\n  // but this fallback is equally fast and easier to maintain\n  // it is also battle tested already in all IE\n  function createSVG(svg) {\n    var content = create(FRAGMENT);\n    var template = create('div');\n    template.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\">' + svg + '</svg>';\n    append(content, template.firstChild.childNodes);\n    return content;\n  }\n\n}(document));\n\n// this \"hack\" tells the library if the browser is IE11 or old Edge\nconst isImportNodeLengthWrong = document.importNode.length != 1;\n\n// IE11 and old Edge discard empty nodes when cloning, potentially\n// resulting in broken paths to find updates. The workaround here\n// is to import once, upfront, the fragment that will be cloned\n// later on, so that paths are retrieved from one already parsed,\n// hence without missing child nodes once re-cloned.\nconst createFragment = isImportNodeLengthWrong ?\n  (text, type, normalize) => document.importNode(\n    createContent(text, type, normalize),\n    true\n  ) :\n  createContent;\n\n// IE11 and old Edge have a different createTreeWalker signature that\n// has been deprecated in other browsers. This export is needed only\n// to guarantee the TreeWalker doesn't show warnings and, ultimately, works\nconst createWalker = isImportNodeLengthWrong ?\n  fragment => document.createTreeWalker(fragment, 1 | 128, null, false) :\n  fragment => document.createTreeWalker(fragment, 1 | 128);\n\n// from a fragment container, create an array of indexes\n// related to its child nodes, so that it's possible\n// to retrieve later on exact node via reducePath\nconst createPath = node => {\n  const path = [];\n  let {parentNode} = node;\n  while (parentNode) {\n    path.push(indexOf.call(parentNode.childNodes, node));\n    node = parentNode;\n    parentNode = node.parentNode;\n  }\n  return path;\n};\n\n// the prefix is used to identify either comments, attributes, or nodes\n// that contain the related unique id. In the attribute cases\n// isµX=\"attribute-name\" will be used to map current X update to that\n// attribute name, while comments will be like <!--isµX-->, to map\n// the update to that specific comment node, hence its parent.\n// style and textarea will have <!--isµX--> text content, and are handled\n// directly through text-only updates.\nconst prefix = 'isµ';\n\n// Template Literals are unique per scope and static, meaning a template\n// should be parsed once, and once only, as it will always represent the same\n// content, within the exact same amount of updates each time.\n// This cache relates each template to its unique content and updates.\nconst cache = umap(new WeakMap);\n\n// a RegExp that helps checking nodes that cannot contain comments\nconst textOnly = /^(?:plaintext|script|style|textarea|title|xmp)$/i;\n\nconst createCache = () => ({\n  stack: [],    // each template gets a stack for each interpolation \"hole\"\n\n  entry: null,  // each entry contains details, such as:\n                //  * the template that is representing\n                //  * the type of node it represents (html or svg)\n                //  * the content fragment with all nodes\n                //  * the list of updates per each node (template holes)\n                //  * the \"wired\" node or fragment that will get updates\n                // if the template or type are different from the previous one\n                // the entry gets re-created each time\n\n  wire: null    // each rendered node represent some wired content and\n                // this reference to the latest one. If different, the node\n                // will be cleaned up and the new \"wire\" will be appended\n});\n\n// the entry stored in the rendered node cache, and per each \"hole\"\nconst createEntry = (type, template) => {\n  const {content, updates} = mapUpdates(type, template);\n  return {type, template, content, updates, wire: null};\n};\n\n// a template is instrumented to be able to retrieve where updates are needed.\n// Each unique template becomes a fragment, cloned once per each other\n// operation based on the same template, i.e. data => html`<p>${data}</p>`\nconst mapTemplate = (type, template) => {\n  const text = instrument(template, prefix, type === 'svg');\n  const content = createFragment(text, type);\n  // once instrumented and reproduced as fragment, it's crawled\n  // to find out where each update is in the fragment tree\n  const tw = createWalker(content);\n  const nodes = [];\n  const length = template.length - 1;\n  let i = 0;\n  // updates are searched via unique names, linearly increased across the tree\n  // <div isµ0=\"attr\" isµ1=\"other\"><!--isµ2--><style><!--isµ3--</style></div>\n  let search = `${prefix}${i}`;\n  while (i < length) {\n    const node = tw.nextNode();\n    // if not all updates are bound but there's nothing else to crawl\n    // it means that there is something wrong with the template.\n    if (!node)\n      throw `bad template: ${text}`;\n    // if the current node is a comment, and it contains isµX\n    // it means the update should take care of any content\n    if (node.nodeType === 8) {\n      // The only comments to be considered are those\n      // which content is exactly the same as the searched one.\n      if (node.data === search) {\n        nodes.push({type: 'node', path: createPath(node)});\n        search = `${prefix}${++i}`;\n      }\n    }\n    else {\n      // if the node is not a comment, loop through all its attributes\n      // named isµX and relate attribute updates to this node and the\n      // attribute name, retrieved through node.getAttribute(\"isµX\")\n      // the isµX attribute will be removed as irrelevant for the layout\n      // let svg = -1;\n      while (node.hasAttribute(search)) {\n        nodes.push({\n          type: 'attr',\n          path: createPath(node),\n          name: node.getAttribute(search),\n          //svg: svg < 0 ? (svg = ('ownerSVGElement' in node ? 1 : 0)) : svg\n        });\n        node.removeAttribute(search);\n        search = `${prefix}${++i}`;\n      }\n      // if the node was a style, textarea, or others, check its content\n      // and if it is <!--isµX--> then update tex-only this node\n      if (\n        textOnly.test(node.tagName) &&\n        node.textContent.trim() === `<!--${search}-->`\n      ){\n        node.textContent = '';\n        nodes.push({type: 'text', path: createPath(node)});\n        search = `${prefix}${++i}`;\n      }\n    }\n  }\n  // once all nodes to update, or their attributes, are known, the content\n  // will be cloned in the future to represent the template, and all updates\n  // related to such content retrieved right away without needing to re-crawl\n  // the exact same template, and its content, more than once.\n  return {content, nodes};\n};\n\n// if a template is unknown, perform the previous mapping, otherwise grab\n// its details such as the fragment with all nodes, and updates info.\nconst mapUpdates = (type, template) => {\n  const {content, nodes} = (\n    cache.get(template) ||\n    cache.set(template, mapTemplate(type, template))\n  );\n  // clone deeply the fragment\n  const fragment = document.importNode(content, true);\n  // and relate an update handler per each node that needs one\n  const updates = nodes.map(handlers, fragment);\n  // return the fragment and all updates to use within its nodes\n  return {content: fragment, updates};\n};\n\n// as html and svg can be nested calls, but no parent node is known\n// until rendered somewhere, the unroll operation is needed to\n// discover what to do with each interpolation, which will result\n// into an update operation.\nconst unroll = (info, {type, template, values}) => {\n  const {length} = values;\n  // interpolations can contain holes and arrays, so these need\n  // to be recursively discovered\n  unrollValues(info, values, length);\n  let {entry} = info;\n  // if the cache entry is either null or different from the template\n  // and the type this unroll should resolve, create a new entry\n  // assigning a new content fragment and the list of updates.\n  if (!entry || (entry.template !== template || entry.type !== type))\n    info.entry = (entry = createEntry(type, template));\n  const {content, updates, wire} = entry;\n  // even if the fragment and its nodes is not live yet,\n  // it is already possible to update via interpolations values.\n  for (let i = 0; i < length; i++)\n    updates[i](values[i]);\n  // if the entry was new, or representing a different template or type,\n  // create a new persistent entity to use during diffing.\n  // This is simply a DOM node, when the template has a single container,\n  // as in `<p></p>`, or a \"wire\" in `<p></p><p></p>` and similar cases.\n  return wire || (entry.wire = persistent(content));\n};\n\n// the stack retains, per each interpolation value, the cache\n// related to each interpolation value, or null, if the render\n// was conditional and the value is not special (Array or Hole)\nconst unrollValues = ({stack}, values, length) => {\n  for (let i = 0; i < length; i++) {\n    const hole = values[i];\n    // each Hole gets unrolled and re-assigned as value\n    // so that domdiff will deal with a node/wire, not with a hole\n    if (hole instanceof Hole)\n      values[i] = unroll(\n        stack[i] || (stack[i] = createCache()),\n        hole\n      );\n    // arrays are recursively resolved so that each entry will contain\n    // also a DOM node or a wire, hence it can be diffed if/when needed\n    else if (isArray(hole))\n      unrollValues(\n        stack[i] || (stack[i] = createCache()),\n        hole,\n        hole.length\n      );\n    // if the value is nothing special, the stack doesn't need to retain data\n    // this is useful also to cleanup previously retained data, if the value\n    // was a Hole, or an Array, but not anymore, i.e.:\n    // const update = content => html`<div>${content}</div>`;\n    // update(listOfItems); update(null); update(html`hole`)\n    else\n      stack[i] = null;\n  }\n  if (length < stack.length)\n    stack.splice(length);\n};\n\n/**\n * Holds all details wrappers needed to render the content further on.\n * @constructor\n * @param {string} type The hole type, either `html` or `svg`.\n * @param {string[]} template The template literals used to the define the content.\n * @param {Array} values Zero, one, or more interpolated values to render.\n */\nfunction Hole(type, template, values) {\n  this.type = type;\n  this.template = template;\n  this.values = values;\n}\n\nconst {create, defineProperties} = Object;\n\n// both `html` and `svg` template literal tags are polluted\n// with a `for(ref[, id])` and a `node` tag too\nconst tag = type => {\n  // both `html` and `svg` tags have their own cache\n  const keyed = umap(new WeakMap);\n  // keyed operations always re-use the same cache and unroll\n  // the template and its interpolations right away\n  const fixed = cache => (template, ...values) => unroll(\n    cache,\n    {type, template, values}\n  );\n  return defineProperties(\n    // non keyed operations are recognized as instance of Hole\n    // during the \"unroll\", recursively resolved and updated\n    (template, ...values) => new Hole(type, template, values),\n    {\n      for: {\n        // keyed operations need a reference object, usually the parent node\n        // which is showing keyed results, and optionally a unique id per each\n        // related node, handy with JSON results and mutable list of objects\n        // that usually carry a unique identifier\n        value(ref, id) {\n          const memo = keyed.get(ref) || keyed.set(ref, create(null));\n          return memo[id] || (memo[id] = fixed(createCache()));\n        }\n      },\n      node: {\n        // it is possible to create one-off content out of the box via node tag\n        // this might return the single created node, or a fragment with all\n        // nodes present at the root level and, of course, their child nodes\n        value: (template, ...values) => unroll(\n          createCache(),\n          {type, template, values}\n        ).valueOf()\n      }\n    }\n  );\n};\n\n// each rendered node gets its own cache\nconst cache$1 = umap(new WeakMap);\n\n// rendering means understanding what `html` or `svg` tags returned\n// and it relates a specific node to its own unique cache.\n// Each time the content to render changes, the node is cleaned up\n// and the new new content is appended, and if such content is a Hole\n// then it's \"unrolled\" to resolve all its inner nodes.\nconst render = (where, what) => {\n  const hole = typeof what === 'function' ? what() : what;\n  const info = cache$1.get(where) || cache$1.set(where, createCache());\n  const wire = hole instanceof Hole ? unroll(info, hole) : hole;\n  if (wire !== info.wire) {\n    info.wire = wire;\n    where.textContent = '';\n    // valueOf() simply returns the node itself, but in case it was a \"wire\"\n    // it will eventually re-append all nodes to its fragment so that such\n    // fragment can be re-appended many times in a meaningful way\n    // (wires are basically persistent fragments facades with special behavior)\n    where.appendChild(wire.valueOf());\n  }\n  return where;\n};\n\nconst html = tag('html');\nconst svg = tag('svg');\n\nfunction css (t) {\n  for (var s = t[0], i = 1, l = arguments.length; i < l; i++)\n    s += arguments[i] + t[i];\n  return s;\n}\n\nconst {defineProperties: defineProperties$1, keys} = Object;\n\nconst accessor = (all, shallow, hook, value, update) => ({\n  configurable: true,\n  get: () => value,\n  set(_) {\n    if (all || _ !== value || (shallow && typeof _ === 'object' && _)) {\n      value = _;\n      if (hook)\n        update.call(this, value);\n      else\n        update.call(this);\n    }\n  }\n});\n\nconst loop = (props, get, all, shallow, useState, update) => {\n  const desc = {};\n  const hook = useState !== noop;\n  const args = [all, shallow, hook];\n  for (let ke = keys(props), y = 0; y < ke.length; y++) {\n    const value = get(props, ke[y]);\n    const extras = hook ? useState(value) : [value, useState];\n    if (update)\n      extras[1] = update;\n    desc[ke[y]] = accessor.apply(null, args.concat(extras));\n  }\n  return desc;\n};\n\nconst noop = () => {};\n\nvar domHandler = ({\n  all = false,\n  shallow = true,\n  useState = noop,\n  getAttribute = (element, key) => element.getAttribute(key)\n} = {}) => (element, props, update) => {\n  const value = (props, key) => {\n    let result = props[key], type = typeof result;\n    if (element.hasOwnProperty(key)) {\n      result = element[key];\n      delete element[key];\n    }\n    else if (element.hasAttribute(key)) {\n      result = getAttribute(element, key);\n      if (type == 'number')\n        result = +result;\n      else if (type == 'boolean')\n        result = !/^(?:false|0|)$/.test(result);\n    }\n    return result;\n  };\n  const desc = loop(props, value, all, shallow, useState, update);\n  return defineProperties$1(element, desc);\n};\n\nconst reactive = domHandler({dom: true});\n\nconst CE = customElements;\nconst {define: defineCustomElement} = CE;\nconst {parse, stringify} = JSON;\nconst {create: create$1, defineProperties: defineProperties$2, getOwnPropertyDescriptor, keys: keys$1} = Object;\n\nconst element = 'element';\nconst ownProps = new WeakMap;\nconst constructors = umap(new Map([[element, {c: HTMLElement, e: element}]]));\n\nconst el = name => document.createElement(name);\n\nconst info = e => constructors.get(e) || constructors.set(e, {\n  c: el(e).constructor,\n  e\n});\n\nconst define = (tagName, definition) => {\n  const {\n    attachShadow,\n    attributeChanged,\n    bound,\n    connected,\n    disconnected,\n    handleEvent,\n    init,\n    observedAttributes,\n    props,\n    render,\n    style\n  } = definition;\n  const initialized = new WeakMap;\n  const statics = {};\n  const proto = {};\n  const listeners = [];\n  const retype = create$1(null);\n  const bootstrap = (element, key, value) => {\n    if (!initialized.has(element)) {\n      initialized.set(element, 0);\n      defineProperties$2(element, {\n        html: {\n          configurable: true,\n          value: content.bind(\n            attachShadow ? element.attachShadow(attachShadow) : element\n          )\n        }\n      });\n      for (let i = 0; i < length; i++) {\n        const {type, options} = listeners[i];\n        element.addEventListener(type, element, options);\n      }\n      if (bound)\n        bound.forEach(bind, element);\n      if (props) {\n        const reProps = {};\n        for (let k = keys$1(props), i = 0; i < k.length; i++) {\n          const key = k[i];\n          const value = props[key];\n          reProps[key] = typeof value === 'object' ? parse(stringify(value)) : value;\n        }\n        ownProps.set(element, reProps);\n        reactive(element, reProps, render);\n      }\n      if (init || render)\n        (init || render).call(element);\n      if (key)\n        element[key] = value;\n    }\n  };\n  for (let k = keys$1(definition), i = 0, {length} = k; i < length; i++) {\n    const key = k[i];\n    if (/^on./.test(key) && !/Options$/.test(key)) {\n      const options = definition[key + 'Options'] || false;\n      const lower = key.toLowerCase();\n      let type = lower.slice(2);\n      listeners.push({type, options});\n      retype[type] = key;\n      if (lower !== key) {\n        type = lower.slice(2, 3) + key.slice(3);\n        retype[type] = key;\n        listeners.push({type, options});\n      }\n    }\n    switch (key) {\n      case 'attachShadow':\n      case 'constructor':\n      case 'observedAttributes':\n      case 'style':\n        break;\n      default:\n        proto[key] = getOwnPropertyDescriptor(definition, key);\n    }\n  }\n  const {length} = listeners;\n  if (length && !handleEvent)\n    proto.handleEvent = {value(event) {\n      this[retype[event.type]](event);\n    }};\n\n  // [props]\n  if (props !== null) {\n    if (props) {\n      for (let k = keys$1(props), i = 0; i < k.length; i++) {\n        const key = k[i];\n        proto[key] = {\n          get() {\n            bootstrap(this);\n            return ownProps.get(this)[key];\n          },\n          set(value) {\n            bootstrap(this, key, value);\n          }\n        };\n      }\n    }\n    else {\n      proto.props = {get() {\n        const props = {};\n        for (let {attributes} = this, {length} = attributes, i = 0; i < length; i++) {\n          const {name, value} = attributes[i];\n          props[name] = value;\n        }\n        return props;\n      }};\n    }\n  }\n  // [/props]\n\n  if (observedAttributes)\n    statics.observedAttributes = {value: observedAttributes};\n  proto.attributeChangedCallback =  {value() {\n    bootstrap(this);\n    if (attributeChanged)\n      attributeChanged.apply(this, arguments);\n  }};\n\n  proto.connectedCallback = {value() {\n    bootstrap(this);\n    if (connected)\n      connected.call(this);\n  }};\n\n  if (disconnected)\n    proto.disconnectedCallback = {value: disconnected};\n\n  const {c, e} = info(definition.extends || element);\n  class MicroElement extends c {}  defineProperties$2(MicroElement, statics);\n  defineProperties$2(MicroElement.prototype, proto);\n  const args = [tagName, MicroElement];\n  if (e !== element)\n    args.push({extends: e});\n  defineCustomElement.apply(CE, args);\n  constructors.set(tagName, {c: MicroElement, e});\n  if (style)\n    document.head.appendChild(el('style')).textContent = style(\n      e === element ? tagName : (e + '[is=\"' + tagName + '\"]')\n    );\n  return MicroElement;\n};\n\n/* istanbul ignore else */\nif (!CE.get('uce-lib'))\n  // theoretically this could be just class { ... }\n  // however, if there is for whatever reason a <uce-lib>\n  // element on the page, it will break once the registry\n  // will try to upgrade such element so ... HTMLElement it is.\n  CE.define('uce-lib', class extends info(element).c {\n    static get define() { return define; }\n    static get render() { return render; }\n    static get html() { return html; }\n    static get svg() { return svg; }\n    static get css() { return css; }\n  });\n\nfunction bind(method) {\n  this[method] = this[method].bind(this);\n}\n\nfunction content() {\n  return render(this, html.apply(null, arguments));\n}\n\nexport { define, html };\n", "export default [\n  \"Hello dear palettist!\",\n  \"Ready for some colors?\",\n  \"Maybe some blue today?\",\n  \"Hello, a lovely color you have today!\"\n];\n", "export function uuid() {\n  return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c) => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));\n}\n", "import {define, html} from \"../_snowpack/pkg/uce.js\";\nimport greetings from \"./greetings.js\";\nimport {uuid} from \"./helpers/uuid.js\";\ndefine(\"palettes-list\", {\n  render() {\n    const palettes = localStorage.palettes ? JSON.parse(localStorage.palettes) : [];\n    const greeting = greetings[Math.floor(Math.random() * greetings.length)];\n    const newPalette = () => {\n      location.replace(`/palette/${uuid()}`);\n    };\n    this.html`\n      <h1>${greeting}</h1>\n      <button onclick=${newPalette} class=\"button\">+</button>\n      ${palettes.length === 0 ? html`\n      <p>Hello, welcome to Palettia! Click on the big + to create your first palette.</p>\n      ` : null}\n    `;\n  }\n});\n", "const state = new Map();\nexport const useState = (identifier, defaults) => {\n  if (localStorage[identifier])\n    Object.assign(defaults, JSON.parse(localStorage[identifier]));\n  const newObject = Object.assign({\n    save() {\n      localStorage[identifier] = JSON.stringify(this);\n    }\n  }, defaults);\n  return state.has(identifier) ? state.get(identifier) : state.set(identifier, newObject) && state.get(identifier);\n};\n", "class HandleStoreClass {\n  constructor() {\n    this.database = this.init();\n  }\n  async init() {\n    return new Promise((resolve, reject) => {\n      const DBOpenRequest = indexedDB.open(\"handles\", 1);\n      DBOpenRequest.onupgradeneeded = (event) => {\n        if (event.oldVersion === 0)\n          DBOpenRequest.result.createObjectStore(\"handles\", {});\n      };\n      DBOpenRequest.onerror = () => reject(DBOpenRequest.error);\n      DBOpenRequest.onblocked = () => console.log(`IndexedDB open database request was blocked`);\n      DBOpenRequest.onsuccess = () => resolve(DBOpenRequest.result);\n    });\n  }\n  async getHandles() {\n    const DB = await this.database;\n    return new Promise((resolve, reject) => {\n      const transaction = DB.transaction([\"handles\"], \"readonly\");\n      const objectStore = transaction.objectStore(\"handles\");\n      const objectStoreRequest = objectStore.getAll();\n      objectStoreRequest.onerror = () => reject(objectStoreRequest.error);\n      objectStoreRequest.onsuccess = async () => resolve(objectStoreRequest.result);\n    });\n  }\n  async getByName(name) {\n    const handles = await this.getHandles();\n    return handles.find((innerHandle) => name === innerHandle.name);\n  }\n  async removeHandle(handle) {\n    const DB = await this.database;\n    await new Promise((resolve, reject) => {\n      const transaction = DB.transaction([\"handles\"], \"readwrite\");\n      const objectStore = transaction.objectStore(\"handles\");\n      const objectStoreRequest = objectStore.delete(handle.name);\n      objectStoreRequest.onsuccess = () => resolve(true);\n      objectStoreRequest.onerror = () => reject(objectStoreRequest.error);\n      transaction.commit();\n    });\n  }\n  async storeHandle(handle) {\n    const DB = await this.database;\n    const handles = await this.getHandles();\n    if (handles.find((innerHandle) => handle.name === innerHandle.name))\n      return;\n    await new Promise((resolve, reject) => {\n      const transaction = DB.transaction([\"handles\"], \"readwrite\");\n      const objectStore = transaction.objectStore(\"handles\");\n      const objectStoreRequest = objectStore.add(handle, handle.name);\n      objectStoreRequest.onsuccess = () => resolve(true);\n      objectStoreRequest.onerror = () => reject(objectStoreRequest.error);\n      transaction.commit();\n    });\n  }\n}\nexport const HandleStore = new HandleStoreClass();\n", "import {define, html} from \"../_snowpack/pkg/uce.js\";\nimport {useState} from \"./helpers/useState.js\";\nimport {HandleStore} from \"./HandleStore.js\";\nlet url;\ndefine(\"palette-edit\", {\n  async render() {\n    const state = useState(\"palette-\" + this.location.params.id, {\n      url: null,\n      fileName: null\n    });\n    const addPhoto = async () => {\n      const [fileHandle] = await window.showOpenFilePicker({\n        types: [{\n          description: \"Images\",\n          accept: {\"image/*\": [\".png\", \".gif\", \".jpeg\", \".jpg\"]}\n        }],\n        startIn: \"pictures\",\n        excludeAcceptAllOption: true,\n        multiple: false\n      });\n      const file = await fileHandle.getFile();\n      state.fileName = file.name;\n      await HandleStore.storeHandle(fileHandle);\n      state.save();\n      const fileData = await fileHandle.getFile();\n      url = URL.createObjectURL(fileData);\n      this.render();\n    };\n    const loadHandle = async () => {\n      if (state.fileName) {\n        const fileHandle = await HandleStore.getByName(state.fileName);\n        await fileHandle.requestPermission();\n        const fileData = await fileHandle.getFile();\n        url = URL.createObjectURL(fileData);\n        this.render();\n      }\n    };\n    const drawImage = (canvas) => {\n      const context = canvas.getContext(\"2d\");\n      const image = document.createElement(\"img\");\n      image.addEventListener(\"load\", () => {\n        console.log(image);\n        context.drawImage(image, 0, 0, window.innerWidth, window.innerHeight, 0, 0, canvas.width, canvas.height);\n      });\n      image.src = url;\n    };\n    this.html`\n     \n\n      <div class=\"toolbar\">\n        ${state.fileName && !url ? html`\n        <button onclick=${loadHandle}>\n          <img src=\"/images/load.svg\" />\n        </button>\n        ` : null}\n\n        <button onclick=${addPhoto}>\n          <img src=\"/images/add_photo.svg\" />\n        </button>\n      </div>\n\n      ${url ? html`<canvas class=\"photo\" ref=${drawImage} />` : null}\n    `;\n  }\n});\n", "import {Router} from \"../_snowpack/pkg/@vaadin/router.js\";\nimport \"./types.js\";\nimport \"./palettes-list.js\";\nimport \"./palette-edit.js\";\nconst router = new Router(document.body);\nrouter.setRoutes([\n  {path: \"/\", component: \"palettes-list\"},\n  {path: \"/palette/:id\", component: \"palette-edit\"},\n  {path: \"(.*)\", component: \"palettes-list\"}\n]);\n"],
  "mappings": "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",
  "names": []
}
